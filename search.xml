<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 学习</title>
      <link href="/2024/06/01/python-xue-xi/"/>
      <url>/2024/06/01/python-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Python3-基础语法"><a href="#1-Python3-基础语法" class="headerlink" title="1.Python3 基础语法"></a>1.Python3 基础语法</h2><h3 id="1-1python3-关键字"><a href="#1-1python3-关键字" class="headerlink" title="1.1python3 关键字"></a>1.1python3 关键字</h3><p>Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-基本数据类型"><a href="#1-2-基本数据类型" class="headerlink" title="1.2 基本数据类型"></a>1.2 基本数据类型</h3><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p>等号（=）用来给变量赋值。</p><p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">"runoob"</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></tbody></table></figure><p>Python允许你同时为多个变量赋值。例如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p><p>您也可以为多个对象指定多个变量。例如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"runoob"</span></span><br></pre></td></tr></tbody></table></figure><p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob” 分配给变量 c。</p><p>Python3 中常见的数据类型有：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>bool（布尔类型）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><p>此外还有一些高级的数据类型，如: 字节数组类型(bytes)。</p><p>内置的 type() 函数可以用来查询变量所指的对象类型，此外还可以用 isinstance 来判断。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt; &lt;<span class="keyword">class</span> <span class="string">'float'</span>&gt; &lt;<span class="keyword">class</span> <span class="string">'bool'</span>&gt; &lt;<span class="keyword">class</span> <span class="string">'complex'</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>==<span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>==<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>+<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>+<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h4><p>字符串的截取的语法格式如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></tbody></table></figure><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p><img src="https://static.jyshare.com/wp-content/uploads/123456-20200923-1.svg" alt="img"></p><p>加号 <strong>+</strong> 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。实例如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">'Runoob'</span>  <span class="comment"># 定义一个字符串变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)           <span class="comment"># 打印整个字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])     <span class="comment"># 打印字符串第一个到倒数第二个字符（不包含倒数第一个字符）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])        <span class="comment"># 打印字符串的第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])      <span class="comment"># 打印字符串第三到第五个字符（包含第五个字符）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])       <span class="comment"># 打印字符串从第三个字符开始到末尾</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)       <span class="comment"># 打印字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">"TEST"</span>)  <span class="comment"># 打印字符串和"TEST"拼接在一起</span></span><br></pre></td></tr></tbody></table></figure><p>Python 使用反斜杠 *<em>*</em> 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 <strong>r</strong>，表示原始字符串：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">'Ru\noob'</span>)</span><br><span class="line">Ru</span><br><span class="line">oob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r'Ru\noob'</span>)</span><br><span class="line">Ru\noob</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p><p><strong>注意：</strong></p><ul><li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li><li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li><li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>4、Python中的字符串不能改变。</li></ul><h4 id="bool-布尔类型"><a href="#bool-布尔类型" class="headerlink" title="bool(布尔类型)"></a>bool(布尔类型)</h4><p>布尔类型特点：</p><ul><li>布尔类型只有两个值：True 和 False。</li><li>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。</li><li>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。</li><li>布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &lt; <span class="number">3</span>)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> == <span class="number">3</span>)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑运算符</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> a)    <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(a))   <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(b)) <span class="comment"># 0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(a))   <span class="comment"># "True"</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意:</strong> 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 <strong>0、空字符串、空列表、空元组</strong>等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。</p><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></tbody></table></figure><p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p><p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">'abcd'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'runoob'</span>, <span class="number">70.2</span> ]  <span class="comment"># 定义一个列表</span></span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">'runoob'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)            <span class="comment"># 打印整个列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])         <span class="comment"># 打印列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment"># 打印列表第二到第四个元素（不包含第四个元素）</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])        <span class="comment"># 打印列表从第三个元素开始到末尾</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)    <span class="comment"># 打印tinylist列表两次</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist)  <span class="comment"># 打印两个列表拼接在一起的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">'abcd'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'runoob'</span>, <span class="number">70.2</span>]</span><br><span class="line">abcd</span><br><span class="line">[<span class="number">786</span>, <span class="number">2.23</span>]</span><br><span class="line">[<span class="number">2.23</span>, <span class="string">'runoob'</span>, <span class="number">70.2</span>]</span><br><span class="line">[<span class="number">123</span>, <span class="string">'runoob'</span>, <span class="number">123</span>, <span class="string">'runoob'</span>]</span><br><span class="line">[<span class="string">'abcd'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'runoob'</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">'runoob'</span>]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong></p><ul><li>1、列表写在方括号之间，元素用逗号隔开。</li><li>2、和字符串一样，列表可以被索引和切片。</li><li>3、列表可以使用 <strong>+</strong> 操作符进行拼接。</li><li>4、列表中的元素是可以改变的。</li></ul><h4 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h4><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同：</p><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果你想创建只有一个元素的元组，需要注意在元素后面添加一个逗号，以区分它是一个元组而不是一个普通的值，这是因为在没有逗号的情况下，Python会将括号解释为数学运算中的括号，而不是元组的表示。</p><p>string、list 和 tuple 都属于 sequence（序列）。</p><p><strong>注意：</strong></p><ul><li>1、与字符串一样，元组的元素不能修改。</li><li>2、元组也可以被索引和切片，方法一样。</li><li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li><li>4、元组也可以使用 <strong>+</strong> 操作符进行拼接。</li></ul><h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4><p>Python 中的集合（Set）是一种无序、可变的数据类型，用于存储唯一的元素。</p><p>集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。</p><p>在 Python 中，集合使用大括号 <strong>{}</strong> 表示，元素之间用逗号 <strong>,</strong> 分隔。</p><p>另外，也可以使用 <strong>set()</strong> 函数创建集合。</p><p><strong>注意：</strong>创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = {value01,value02,...}</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></tbody></table></figure><h4 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h4><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p><strong>注意：</strong></p><ul><li>1、字典是一种映射类型，它的元素是键值对。</li><li>2、字典的关键字必须为不可变类型，且不能重复。</li><li>3、创建空字典使用 **{ }**。</li></ul><h4 id="bytes-类型"><a href="#bytes-类型" class="headerlink" title="bytes 类型"></a>bytes 类型</h4><p>创建 bytes 对象的方式有多种，最常见的方式是使用 b 前缀：</p><p>bytes 类型通常用于处理二进制数据，比如图像文件、音频文件、视频文件等等。在网络编程中，也经常使用 bytes 类型来传输二进制数据。</p><p>此外，也可以使用 bytes() 函数将其他类型的对象转换为 bytes 类型。bytes() 函数的第一个参数是要转换的对象，第二个参数是编码方式，如果省略第二个参数，则默认使用 UTF-8 编码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">bytes</span>(<span class="string">"hello"</span>, encoding=<span class="string">"utf-8"</span>)</span><br></pre></td></tr></tbody></table></figure><p>与字符串类型类似，bytes 类型也支持许多操作和方法，如切片、拼接、查找、替换等等。同时，由于 bytes 类型是不可变的，因此在进行修改操作时需要创建一个新的 bytes 对象。</p><h3 id="1-3Python数据类型转换"><a href="#1-3Python数据类型转换" class="headerlink" title="1.3Python数据类型转换"></a>1.3Python数据类型转换</h3><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h3 id="1-4-Python-运算符"><a href="#1-4-Python-运算符" class="headerlink" title="1.4 Python 运算符"></a>1.4 Python 运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 31</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -11</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 210</td></tr><tr><td align="left">/</td><td align="left">除 - x 除以 y</td><td align="left">b / a 输出结果 2.1</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 1</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的21次方</td></tr><tr><td align="left">//</td><td align="left">取整除 - 往小的方向取整数</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>以下假设变量 a 为 10，变量 b 为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 True。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 True。</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c ** a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr><tr><td align="left">:=</td><td align="left">海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。<strong>Python3.8 版本新增运算符</strong>。</td><td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<code>if (n := len(a)) &gt; 10:    print(f"List is too long ({n} elements, expected &lt;= 10)")</code></td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 <strong>-x-1</strong></td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td><td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h4 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(x) != id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><h3 id="1-5-Python-列表推导式"><a href="#1-5-Python-列表推导式" class="headerlink" title="1.5 Python 列表推导式"></a>1.5 Python 列表推导式</h3><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p><p>Python 支持各种数据结构的推导式：</p><ul><li>列表(list)推导式</li><li>字典(dict)推导式</li><li>集合(set)推导式</li><li>元组(tuple)推导式</li></ul><h3 id="1-6-迭代器二号生成器"><a href="#1-6-迭代器二号生成器" class="headerlink" title="1.6 迭代器二号生成器"></a>1.6 迭代器二号生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</p><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p><p>字符串，列表或元组对象都可用于创建迭代器。</p><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">      self.a = <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br></pre></td></tr></tbody></table></figure><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></tbody></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）。</p><p><strong>yield</strong> 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>当在生成器函数中使用 <strong>yield</strong> 语句时，函数的执行将会暂停，并将 <strong>yield</strong> 后面的表达式作为当前迭代的值返回。</p><p>然后，每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><p>下面是一个简单的示例，展示了生成器函数的使用：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></tbody></table></figure><p>以上实例中，<strong>countdown</strong> 函数是一个生成器函数。它使用 yield 语句逐步产生从 n 到 1 的倒数数字。在每次调用 yield 语句时，函数会返回当前的倒数值，并在下一次调用时从上次暂停的地方继续执行。</p><p>通过创建生成器对象并使用 next() 函数或 for 循环迭代生成器，我们可以逐步获取生成器函数产生的值。在这个例子中，我们首先使用 next() 函数获取前三个倒数值，然后通过 for 循环获取剩下的两个倒数值。</p><p>生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。此外，生成器还可以与其他迭代工具（如for循环）无缝配合使用，提供简洁和高效的迭代方式。</p><h3 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h3><h2 id="2-Python3-高级教程"><a href="#2-Python3-高级教程" class="headerlink" title="2.Python3 高级教程"></a>2.Python3 高级教程</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序是怎样跑起来的</title>
      <link href="/2024/05/31/cheng-xu-shi-zen-yang-pao-qi-lai-de/"/>
      <url>/2024/05/31/cheng-xu-shi-zen-yang-pao-qi-lai-de/</url>
      
        <content type="html"><![CDATA[<p>主要要求：机器语言程序被加载到内存，然后由CPU进行解释和执行，从而完成对计算机系统的控制和数据运算等任务。</p><h2 id="1-CPU是什么？"><a href="#1-CPU是什么？" class="headerlink" title="1.CPU是什么？"></a>1.CPU是什么？</h2><p>CPU是计算机的大脑，由数百万至数亿个晶体管构成，是负责对最终转换成机器语言的程序内容进行解释和执行的设备。</p><p>问题： </p><p>1.什么是程序？计算机每一步动作的一组指令</p><p>2.程序由什么组成？ 数据与指令</p><p>3.什么是机器语言？ CPU可以直接执行解释的语言</p><p>4.运行中的程序存放在什么地方？ 内存</p><p>5.什么是内存地址？ 表示数据与指令在内存中的位置的数值</p><p>6.在计算机的组成部件中，负责对程序进行解释和运行的是哪个？</p><p>CPU</p><h3 id="1-1-CPU的内部构造"><a href="#1-1-CPU的内部构造" class="headerlink" title="1.1 CPU的内部构造"></a>1.1 CPU的内部构造</h3><p>CPU本质是名为集成电路的电子部件，由大量晶体管组成。</p><p>从功能上看：CPU由寄存器、控制器、运算器和时钟组成。如图1.1所示</p><p>![屏幕截图 2024-05-31 220019](D:\Lenovo\source_posts\程序是怎样跑起来的\屏幕截图 2024-05-31 220019.png)</p><p>其中，<strong>寄存器</strong>存放指令、数据；控制器负责将内存中的指令和数据读入寄存器，并根据指令的执行结果对计算机进行控制；<strong>运算器</strong>负责运算从内存中读入寄存器的数据；<strong>时钟</strong>负责产生控制CPU工作节律的时钟信号。</p><p>通常所说的内存是指<strong>主存储器</strong>，简称主存。内存由一些可读写的存储元件构成，每个字节都分配了一个被称为地址的编号。CPU通过地址就可以读取内存中的指令和数据，也可以将数据写入内存，关闭计算机后，内存中的数据和指令就会消失。</p><p>程序运行原理：</p><p>当程序起点时，CPU中的控制器根据时钟信号从内存中读取指令和数据。然后运算器根据指令对数据进行运算，控制器根据运算结果控制计算机进行指定的操作。</p><h3 id="1-2CPU是寄存器的集合体"><a href="#1-2CPU是寄存器的集合体" class="headerlink" title="1.2CPU是寄存器的集合体"></a>1.2CPU是寄存器的集合体</h3><p>将汇编语言转换为机器语言的过程是汇编。反之，则反汇编。</p><p>代码清单1-1</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov1 -4(%ebp), %eax  # 将内存中的值读入eax</span><br><span class="line">add1 -8(%ebp), %eax  # 将内存中的值累加到eax</span><br><span class="line">mov1 %eax, -12(%ebp) # 将eax中的值存入到内存中</span><br></pre></td></tr></tbody></table></figure><p>代码清单1-1中，eax和ebp都代表CPU内部寄存器的名称。</p><p>CPU类型不同，则内部的寄存器数量、类型及寄存器中能存储的数据长度也有所不同。</p><p>表1-1 寄存器的主要类型及其功能</p><table><thead><tr><th>寄存器的类型</th><th>功能</th></tr></thead><tbody><tr><td>累加器</td><td>存放执行运算的数据和运算结果</td></tr><tr><td>标志寄存器</td><td>存放运算处理后的CPU状态</td></tr><tr><td>程序计数器</td><td>存放下一条指令所在内存的地址</td></tr><tr><td>基址寄存器</td><td>存放数据内存的起始地址</td></tr><tr><td>变址寄存器</td><td>存放基址寄存器的相对地址</td></tr><tr><td>通用寄存器</td><td>存放任意数据</td></tr><tr><td>指令寄存器</td><td>存放指令。程序员不能通过程序读取它的值</td></tr><tr><td>栈寄存器</td><td>存放栈空间的起始地址</td></tr></tbody></table><p>在代码清单1-1中，eax就是累加器，ebp就是基址寄存器。</p><p>一般来说，程序计数器，累加器、标志寄存器、指令寄存器、栈寄存器各仅有一个，其它类型可以由多个。</p><p>条件、循环：</p><p>CPU会根据标准寄存器的结果来判断是否执行跳转指令。</p><p>比较方式：判断累加器的值XXX和通用寄存器中的值YYY，</p><p>就是执行XXX-YYY。若为正数，则标志寄存器后三位为001；为零则为010；为负数则为100</p><p>函数调用：</p><p>在执行call指令之前，会将程序计数器中的地址存放在栈中，当调用函数执行完毕后，就会把栈中的地址return给程序计数器</p><h3 id="1-3-用基址和变址实现数组"><a href="#1-3-用基址和变址实现数组" class="headerlink" title="1.3 用基址和变址实现数组"></a>1.3 用基址和变址实现数组</h3><p>基址寄存器存储的是数组的起始地址，变址寄存器存储的值相当于数组的下标。</p><p>比如，访问地址10000000-1000FFFF时，基址寄存器存储10000000，变址寄存器可以存储00000000-0000FFFF范围内的值，CPU就会将两个值相加得出真实地址值</p><h3 id="1-4-CPU的功能指令表"><a href="#1-4-CPU的功能指令表" class="headerlink" title="1.4 CPU的功能指令表"></a>1.4 CPU的功能指令表</h3><table><thead><tr><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>数据床送指令</td><td>在寄存器和内存，内存和内存，以及寄存器和外部设备之间读写数据</td></tr><tr><td>运算指令</td><td>用累加器执行算数运算、逻辑运算、比较运算、移位运算等操作</td></tr><tr><td>跳转指令</td><td>执行条件分支、循环和无条件跳转</td></tr><tr><td>调用/返回指令</td><td>调用函数/返回函数调用处</td></tr></tbody></table><p>外部设备是指连接到计算机上的键盘、鼠标、显示器、磁盘、打印机等。</p><h2 id="2-用二进制来理解数据"><a href="#2-用二进制来理解数据" class="headerlink" title="2.用二进制来理解数据"></a>2.用二进制来理解数据</h2><p>问：</p><ol><li><p>32比特是多少字节？4字节</p></li><li><p>二进制01011100用十进制表示是多少？92</p></li><li><p>二进制数00001111左移2位，得到的结果是原数的多少倍？ 4倍</p></li><li><p>以2的补码形式表示的8位二进制数11111111用十进制表示是多少？-1</p></li><li><p>以2的补码形式表示的8位二进制数10101010用16位二进制表示是多少？ 1111 1111 1010 1010</p></li><li><p>要反转图案中的一部分点，应该使用哪种逻辑运算？</p></li></ol><p>​        逻辑异或运算</p><p>逻辑异或会将所有与1对应的位反转，逻辑非会将所有的位反转。</p><h3 id="2-1-计算机用二进制处理信息的原因"><a href="#2-1-计算机用二进制处理信息的原因" class="headerlink" title="2.1 计算机用二进制处理信息的原因"></a>2.1 计算机用二进制处理信息的原因</h3><p>计算机内部是由集成电路的电子元件构成，集成电路的每根引脚只能有两种状态。</p><p>在计算机中，比特是最小单位，字节是基本单位。内存和硬盘中，数据以字节为单位进行存储，也以字节为单位进行读写的</p><h3 id="2-2-二进制是什么"><a href="#2-2-二进制是什么" class="headerlink" title="2.2 二进制是什么"></a>2.2 二进制是什么</h3><p>二进制代表的是以2为基数来计数的。</p><h3 id="2-3-移位运算与乘除运算的关系"><a href="#2-3-移位运算与乘除运算的关系" class="headerlink" title="2.3 移位运算与乘除运算的关系"></a>2.3 移位运算与乘除运算的关系</h3><p>左移代表在原数的基础上进行乘运算，右移代表的是除运算。</p><h3 id="2-4便于计算机处理的”2的补码“"><a href="#2-4便于计算机处理的”2的补码“" class="headerlink" title="2.4便于计算机处理的”2的补码“"></a>2.4便于计算机处理的”2的补码“</h3><p>为什么要有补码，就是因为计算机只有加法器。</p><p>补码的反码+1就是原码。</p><p>正数的原码，反码，补码都一样</p><h3 id="2-5-逻辑右移与算术右移的区别"><a href="#2-5-逻辑右移与算术右移的区别" class="headerlink" title="2.5 逻辑右移与算术右移的区别"></a>2.5 逻辑右移与算术右移的区别</h3><p>逻辑右移：高位填充0，倍数不是原来的几分之几了</p><p>算术右移：高位用符号位进行填充。</p><p>符号扩展：就是将一个8位的二进制数转为16位或32位二进制数。 只需要使用符号位的值进行高位填充</p><h2 id="3-计算机在计算小数时会出错的原因"><a href="#3-计算机在计算小数时会出错的原因" class="headerlink" title="3.计算机在计算小数时会出错的原因"></a>3.计算机在计算小数时会出错的原因</h2><h3 id="3-1-将0-1累加100次的结果不是10"><a href="#3-1-将0-1累加100次的结果不是10" class="headerlink" title="3.1 将0.1累加100次的结果不是10"></a>3.1 将0.1累加100次的结果不是10</h3><p>使用C语言会得到结果为10.000002</p><h3 id="3-2-如何用二进制表示小数"><a href="#3-2-如何用二进制表示小数" class="headerlink" title="3.2 如何用二进制表示小数"></a>3.2 如何用二进制表示小数</h3><p>使用小数部分×位权</p><h3 id="3-3-计算机出错原因"><a href="#3-3-计算机出错原因" class="headerlink" title="3.3 计算机出错原因"></a>3.3 计算机出错原因</h3><p>某些十进制小数无法准确的转换成二进制数</p><h3 id="3-4-什么是浮点数？"><a href="#3-4-什么是浮点数？" class="headerlink" title="3.4 什么是浮点数？"></a>3.4 什么是浮点数？</h3><p>浮点数将小数分为符号、尾数、基数和指数四个部分来表示。</p><p><img src="D:\Lenovo\source_posts\程序是怎样跑起来的\浮点数.png"></p><p>很多编程语言中都提供了两种表示小数的数据类型，分别是<strong>双精度浮点数</strong>和<strong>单精度浮点数</strong>。双精度浮点数类型用 64 位、单精度浮点数类型用 32 位来表示全体小数。在 C 语言中，双精度浮点数类型和单精度浮点数类型分别用 double 和 float 来表示。</p><p><img src="D:\Lenovo\source_posts\程序是怎样跑起来的\浮点数内部构造.png" alt="浮点数内部构造"></p><p>尾数部分和指数部分并不只是单单存储着用整数表示的二进制数。尾数部分用的是“将小数点前面的值固定为 1 的规格化表示法，而指数部分用的则是“移码（excess）表示法”。指数位越多，尾数位则越少，其表示的范围越大，但精度就会变差，反之，指数位越少，尾数位则越多，表示的范围越小，但精度就会变好。</p><h3 id="3-5-规格化表示法-和-移码表示法"><a href="#3-5-规格化表示法-和-移码表示法" class="headerlink" title="3.5 规格化表示法 和 移码表示法"></a>3.5 规格化表示法 和 移码表示法</h3><p>尾数使用规格化表示法</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1011.0011        ...原数</span><br><span class="line">1.0110011        ...右移使得正数部分的第1位为1</span><br><span class="line">1.01100110000000000000000  ... 将小数部分扩展至23位</span><br><span class="line">01100110000000000000000    ... 只保留小数部分，完成规格化表示</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>、</p><p>指数使用移码表示法</p><table><thead><tr><th>实际值（二进制）</th><th>实际值（十进制）</th><th>移码表示法中的对应值（十进制）</th></tr></thead><tbody><tr><td>11111111</td><td>255</td><td>128（255-127）</td></tr><tr><td>11111110</td><td>254</td><td>127（254-127）</td></tr><tr><td>….</td><td>….</td><td>…</td></tr><tr><td>01111111</td><td>127</td><td>0</td></tr><tr><td>01111110</td><td>126</td><td>-1</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>00000001</td><td>1</td><td>-126</td></tr><tr><td>00000000</td><td>0</td><td>-127</td></tr></tbody></table><h3 id="3-6-如何避免计算机出错"><a href="#3-6-如何避免计算机出错" class="headerlink" title="3.6 如何避免计算机出错"></a>3.6 如何避免计算机出错</h3><p>回避策略与使用正数代替小数。</p><p>BCD就是一种使用正数代替小数的格式</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/02/29/dong-tai-gui-hua/"/>
      <url>/2024/02/29/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2024/02/29/tan-xin-suan-fa/"/>
      <url>/2024/02/29/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2024/02/29/hui-su-suan-fa/"/>
      <url>/2024/02/29/hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/02/29/er-cha-shu/"/>
      <url>/2024/02/29/er-cha-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2024/02/29/zhan-yu-dui-lie/"/>
      <url>/2024/02/29/zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2024/02/29/zi-fu-chuan/"/>
      <url>/2024/02/29/zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/02/28/hello-world/"/>
      <url>/2024/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2024/02/26/lian-biao/"/>
      <url>/2024/02/26/lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="1-链表的概念"><a href="#1-链表的概念" class="headerlink" title="1.链表的概念"></a>1.链表的概念</h2><p>链表是一种通过指针串联在一起的线性结构。</p><p>每一个节点由两部分组成：数据域，指针域</p><p>链表的入口称为头节点，及head</p><h3 id="1-1链表的类型"><a href="#1-1链表的类型" class="headerlink" title="1.1链表的类型"></a>1.1链表的类型</h3><ul><li>单链表</li><li>双链表</li><li>循环链表</li></ul><h3 id="1-2链表节点的定义"><a href="#1-2链表节点的定义" class="headerlink" title="1.2链表节点的定义"></a>1.2链表节点的定义</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>{</span><br><span class="line">        <span class="built_in">this</span>.val =val;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(ListNode next)</span>{</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-链表的操作"><a href="#1-3-链表的操作" class="headerlink" title="1.3 链表的操作"></a>1.3 链表的操作</h3><h4 id="1-3-1删除节点"><a href="#1-3-1删除节点" class="headerlink" title="1.3.1删除节点"></a>1.3.1删除节点</h4><p>将要删除的前一个节点的指针指向删除节点指针指向的节点</p><p><img src="C:\Users\启明\AppData\Roaming\Typora\typora-user-images\image-20240226180558619.png" alt="image-20240226180558619"></p><h4 id="1-3-2添加节点"><a href="#1-3-2添加节点" class="headerlink" title="1.3.2添加节点"></a>1.3.2添加节点</h4><p>将要添加节点的位置的那个节点A的指针指向要添加的这个节点B，这个节点B的指针指向A节点指针原来指向的那个节点C</p><p><img src="C:\Users\启明\AppData\Roaming\Typora\typora-user-images\image-20240226180709032.png" alt="image-20240226180709032"></p><h3 id="1-4-善于利用虚拟头节点"><a href="#1-4-善于利用虚拟头节点" class="headerlink" title="1.4 善于利用虚拟头节点"></a>1.4 善于利用虚拟头节点</h3><h2 id="2-力扣"><a href="#2-力扣" class="headerlink" title="2.力扣"></a>2.力扣</h2><h3 id="2-1-设计链表"><a href="#2-1-设计链表" class="headerlink" title="2.1 设计链表"></a>2.1 设计链表</h3><p><strong>【题目描述】</strong></p><p>设计一个链表类，实现六个接口：</p><ul><li>获取链表的第index节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表的第index节点前面插入一个节点</li><li>删除链表的第index节点</li><li>打印当前链表</li></ul><p>注意：index从0开始</p><p>力扣 <a href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList {</span><br><span class="line">private LinkedNode virtualHead;</span><br><span class="line"></span><br><span class="line">    public MyLinkedList() {</span><br><span class="line">virtualHead = new LinkedNode(0);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public int get(int index) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void addAtHead(int val) {</span><br><span class="line">LinkedNode next = virtualHead.next;</span><br><span class="line">new LinkedNode </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void addAtTail(int val) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void addAtIndex(int index, int val) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void deleteAtIndex(int index) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-反转链表"><a href="#2-2-反转链表" class="headerlink" title="2.2 反转链表"></a>2.2 反转链表</h3><p><strong>【题目描述】</strong></p><p>反转一个单链表。要求是不能申请额外的内存空间</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><h4 id="2-2-1双指针法"><a href="#2-2-1双指针法" class="headerlink" title="2.2.1双指针法"></a>2.2.1双指针法</h4><p>cur指针指向头节点，</p><p>pre指针，初始为null，</p><p>temp指针保存cur的下一个节点</p><p><img src="C:\Users\启明\AppData\Roaming\Typora\typora-user-images\image-20240226210022695.png" alt="image-20240226210022695"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-2-2-递归法"><a href="#2-2-2-递归法" class="headerlink" title="2.2.2 递归法"></a>2.2.2 递归法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre, ListNode cur)</span> {</span><br><span class="line"><span class="keyword">if</span>(cur==<span class="literal">null</span>){</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">}</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>{</span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">null</span>,head);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-删除倒数第n个节点"><a href="#2-3-删除倒数第n个节点" class="headerlink" title="2.3 删除倒数第n个节点"></a>2.3 删除倒数第n个节点</h3><p><strong>【题目描述】</strong></p><p>删除链表中倒数第n个节点（n从1开始）</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><p>双指针法+虚拟头节点</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span> &amp;&amp; fast!=<span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// fast 指针移动 n步</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(fast.next!=<span class="literal">null</span>){</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow =slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 找到要删除的节点的前一个一个节点slow</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为什么是返回这个而不是head ?</span></span><br><span class="line">    <span class="comment">// 如果刚好删除的是head,则返回head就只是一个节点</span></span><br><span class="line">    <span class="comment">// 而dummyHead.next才是一个链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-环形链表"><a href="#2-4-环形链表" class="headerlink" title="2.4 环形链表"></a>2.4 环形链表</h3><p><strong>【题目描述】</strong></p><p>判断一个链表是否有环，如果有环，则找到入环的第一个节点，如果无环，则返回null</p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></p><h4 id="2-4-1判断链表是否有环"><a href="#2-4-1判断链表是否有环" class="headerlink" title="2.4.1判断链表是否有环"></a>2.4.1判断链表是否有环</h4><p>双指针判断，fast指针一次走两步，slow指针一次走一步，如果存在fast= slow，则代表有环</p><h4 id="2-4-2-寻找环的入口"><a href="#2-4-2-寻找环的入口" class="headerlink" title="2.4.2 寻找环的入口"></a>2.4.2 寻找环的入口</h4><p>x代表从头节点到入口节点的距离，y代表从入口节点到相遇节点的距离，Z代表从相遇节点到入口节点的距离</p><p>fast节点比slow节点快，相遇时，slow节点一定是还未转一圈。</p><p>为什么呢？</p><p>如果slow节点已经转一圈了，因为fast相对于slow每次走一步，那么此时fast转了两圈，他们应该相遇两次了</p><p>所有有 slow = x+y, fast = x+y+n(z+y)</p><p>2(x+y) = x+y+n(z+y);</p><p>即是 x = (n-1)(z+y)+z;</p><p>如果只转了一圈， 则 x=z, 如果两个指针同时从头节点和相遇节点出发，则，他们相遇时的节点就是入口节点。</p><p>如果n&gt;1,结果也是一样</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>){</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇</span></span><br><span class="line">        <span class="keyword">if</span>(slow==fast){</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> fast;</span><br><span class="line">            <span class="keyword">while</span>(index1!=index2){</span><br><span class="line">                index1 = index1.next;</span><br><span class="line">                index2 = index2.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2024/02/26/shu-zu/"/>
      <url>/2024/02/26/shu-zu/</url>
      
        <content type="html"><![CDATA[<p>s</p><h2 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1. 数组的概念"></a>1. 数组的概念</h2><p>数组是存储在连续内存空间上相同类型数据的集合。</p><p>Java中一维数组内存连续，二维数组中的元素为一维数组，一维数组是连续的，但元素与元素之间的内存地址不一定连续</p><p>在Java中，可以使用<code>System.identityHashCode()</code>方法来获取对象（包括数组）的内存地址。该方法返回一个32位的哈希值，但并不能直接表示真正的内存地址。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMemoryAddress</span><span class="params">(<span class="type">int</span>[] arr)</span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">memoryAddress</span> <span class="operator">=</span> System.identityHashCode(element);</span><br><span class="line">            System.out.println(<span class="string">"Element "</span>+element+ <span class="string">"  memoryAddress "</span>+memoryAddress);</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-1二分查找"><a href="#1-1二分查找" class="headerlink" title="1.1二分查找"></a>1.1二分查找</h3><p>二分查找的前提是数组是有序的且无重复元素。</p><p><strong>【题目描述】</strong></p><p>在一个有序且无重复元素的数组nums中，寻找一个元素target,如果找到，返回对应下标，没有返回-1</p><p>力扣 <a href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p><p>主要问题：边界条件</p><h4 id="1-1-1左闭右闭-left-right"><a href="#1-1-1左闭右闭-left-right" class="headerlink" title="1.1.1左闭右闭[left,right]"></a>1.1.1左闭右闭[left,right]</h4><p>定义target在一个[] 区间</p><ul><li>那left与right相等的情况在区间是有意义的，所以while(left&lt;=right)</li><li>如果nums[mid] &gt; target, 则需要更新搜索范围右下标为mid-1</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt; target){</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-1-2左开右闭-left-right"><a href="#1-1-2左开右闭-left-right" class="headerlink" title="1.1.2左开右闭[left,right]"></a>1.1.2左开右闭[left,right]</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right){</span><br><span class="line">            middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target){</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target){</span><br><span class="line">                right = middle;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-移除元素"><a href="#1-2-移除元素" class="headerlink" title="1.2 移除元素"></a>1.2 移除元素</h3><p><strong>【题目描述】</strong></p><p>原地移除数组中所有等于val的元素，要求不能使用额外的辅助空间，及空间复杂度为O(1),返回移除元素后的新数组的size</p><p>力扣 <a href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p><h4 id="1-2-1暴力解法"><a href="#1-2-1暴力解法" class="headerlink" title="1.2.1暴力解法"></a>1.2.1暴力解法</h4><p>双重循环，第一重循环寻找 val, 第二重循环覆盖</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> val)</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++){</span><br><span class="line">         <span class="keyword">if</span>(arr[i] == val){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size ; j++){</span><br><span class="line">                arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">            }</span><br><span class="line">            i-- ;</span><br><span class="line">            size --;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2-2双指针法（快慢指针法）"><a href="#1-2-2双指针法（快慢指针法）" class="headerlink" title="1.2.2双指针法（快慢指针法）"></a>1.2.2双指针法（快慢指针法）</h4><p><strong>双指针法（快慢指针法）</strong>：通过一个快指针和慢指针在一个for循环内完成两个for循环的工作</p><p>快慢指针同时自增，条件满足时，都会将fastIndex下标的赋值给 slowIndex下标的数，条件不满足时，slowindex就不会增加，此时双指针错位</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span>{</span><br><span class="line"><span class="comment">// 定义两个指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;fastIndex &lt; nums.length ; fastIndex++){</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != val){</span><br><span class="line">            nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-长度最小的子数组"><a href="#1-3-长度最小的子数组" class="headerlink" title="1.3 长度最小的子数组"></a>1.3 长度最小的子数组</h3><p><strong>【题目描述】</strong></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><h4 id="1-3-1暴力解法"><a href="#1-3-1暴力解法" class="headerlink" title="1.3.1暴力解法"></a>1.3.1暴力解法</h4><p>双重循环，第一重循环获取i,代表从i开始的第二重循环</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> nums[])</span>{</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++){</span><br><span class="line">            sum = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &lt; nums.length ; j++){</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target) {</span><br><span class="line">                    length = j-i+<span class="number">1</span>;</span><br><span class="line">                    result = result &lt; length ?result:length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result==Integer.MAX_VALUE? <span class="number">0</span>:result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-3-2滑动窗口"><a href="#1-3-2滑动窗口" class="headerlink" title="1.3.2滑动窗口"></a>1.3.2滑动窗口</h4><p>滑动窗口： 就是不断地调节子数组的起始位置和终止位置。</p><p>两个指针：指针之间中的部分是窗口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> nums[])</span>{</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起始指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 终止指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;end&lt; nums.length;end++){</span><br><span class="line">        sum += nums[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 滑动窗口的精髓</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target){</span><br><span class="line">            <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> end -start +<span class="number">1</span>;</span><br><span class="line">            result = result &lt; subLength ? result: subLength;</span><br><span class="line">            sum = sum - nums[start] ;</span><br><span class="line">            start ++ ; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result==Integer.MAX_VALUE? <span class="number">0</span>:result;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-螺旋矩阵II"><a href="#1-4-螺旋矩阵II" class="headerlink" title="1.4 螺旋矩阵II"></a>1.4 螺旋矩阵II</h3><p><strong>【题目描述】</strong></p><p>给出一个正整数n,按从外向内的螺旋顺序打印1到n^2的所有数值</p><p><strong>螺旋不变量</strong></p><p>即按照左闭右开或左开右闭的原则，有一定规则的“画”下来</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 每循环一圈的起始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环的圈数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> n /<span class="number">2</span> ;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">// 循环一圈后的偏移量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 中心位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> n/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(loop--&gt;<span class="number">0</span>){</span><br><span class="line">        i = x;</span><br><span class="line">        j = y;</span><br><span class="line">        <span class="comment">// 从左向右填充</span></span><br><span class="line">        <span class="keyword">for</span>(j=y;j&lt;y+n-offset;j++){</span><br><span class="line">            res[x][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从上到下填充</span></span><br><span class="line">         <span class="keyword">for</span>(i=x;i&lt;x+n-offset;i++){</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从右到左填充</span></span><br><span class="line">         <span class="keyword">for</span>(;j&gt;y;j--){</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从下到上填充</span></span><br><span class="line">         <span class="keyword">for</span>(;i&gt;x;i--){</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 起始位置发生改变</span></span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 偏移量发生改变</span></span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>){</span><br><span class="line">        res[mid][mid] = n*n ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序的性能分析</title>
      <link href="/2024/02/26/cheng-xu-de-xing-neng-fen-xi/"/>
      <url>/2024/02/26/cheng-xu-de-xing-neng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-时间复杂度分析"><a href="#1-时间复杂度分析" class="headerlink" title="1.时间复杂度分析"></a>1.时间复杂度分析</h2><p>时间复杂度是一个<strong>函数</strong>，它定性描述了算法的运行时间。</p><p>O 用来表示上界，用它表示算法在最坏情况下运行时间的上界，就是对任意数据输入的运行时间的上界。</p><p>O 代表的就是一般情况，一般是数据是无序的。</p><h3 id="1-1如何描述时间时间复杂度"><a href="#1-1如何描述时间时间复杂度" class="headerlink" title="1.1如何描述时间时间复杂度"></a>1.1如何描述时间时间复杂度</h3><ul><li>考虑数据规模的差异</li><li>复杂表达式的简化</li><li>log以什么为底</li></ul><h3 id="1-2-递归算法的时间复杂度分析"><a href="#1-2-递归算法的时间复杂度分析" class="headerlink" title="1.2 递归算法的时间复杂度分析"></a>1.2 递归算法的时间复杂度分析</h3><p>递归算法的时间复杂度本质上要看<strong>递归的次数</strong>与<strong>递归中的操作次数</strong>的乘积</p><h2 id="2-空间复杂度分析"><a href="#2-空间复杂度分析" class="headerlink" title="2.空间复杂度分析"></a>2.空间复杂度分析</h2><p>空间复杂度考虑的是程序执行时占用内存空间的大小，而不是可执行文件的大小</p><p>在递归调用的时候，会出现空间复杂度为O（logn）的情况</p><h3 id="2-1-递归算法空间复杂度分析"><a href="#2-1-递归算法空间复杂度分析" class="headerlink" title="2.1 递归算法空间复杂度分析"></a>2.1 递归算法空间复杂度分析</h3><p>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归的深度</p><h4 id="2-1-1-斐波那契数"><a href="#2-1-1-斐波那契数" class="headerlink" title="2.1.1 斐波那契数"></a>2.1.1 斐波那契数</h4><p>非递归算法 时间复杂度（o(n)） 空间复杂度（o(1)）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci1</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) {</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (num&lt;<span class="number">3</span>){</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= num; i++) {</span><br><span class="line">          third = first + second;</span><br><span class="line">          first = second;</span><br><span class="line">          second = third;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> third;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>递归算法 时间复杂度（o(2^n)） 空间复杂度（o(n)）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span>{</span><br><span class="line"><span class="keyword">if</span>(i &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(i-<span class="number">1</span>)+fibonacci(i-<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化递归算法  时间复杂度（o(n)） 空间复杂度（o(n)）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second, <span class="type">int</span> n)</span>{</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">3</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>){</span><br><span class="line">        <span class="keyword">return</span> first+second;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> fibonacci(second,first+second,n-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-1-2-二分查找法"><a href="#2-1-2-二分查找法" class="headerlink" title="2.1.2 二分查找法"></a>2.1.2 二分查找法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>{</span><br><span class="line"><span class="keyword">if</span>(r&gt;=<span class="number">1</span>){</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]==x){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&gt;x){</span><br><span class="line">            <span class="keyword">return</span> binary_search(arr,l,mid-<span class="number">1</span>,x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度为 O（logn） 空间复杂度为 O(logn)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从0到1手写RPC</title>
      <link href="/2024/02/24/cong-0-dao-1-shou-xie-rpc/"/>
      <url>/2024/02/24/cong-0-dao-1-shou-xie-rpc/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="#什么是RPC"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E4%BB%80%E4%B9%88%E6%98%AFrpc">#</a><strong>什么是RPC</strong></h3><p>RPC（Remote Procedure Call）远程过程调用，简言之就是像调用本地方法一样调用远程服务。目前外界使用较多的有gRPC、Dubbo、Spring Cloud等。相信大家对RPC的概念都已经很熟悉了，这里不做过多介绍。</p><h3 id="为啥要自己写"><a href="#为啥要自己写" class="headerlink" title="#为啥要自己写"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E4%B8%BA%E5%95%A5%E8%A6%81%E8%87%AA%E5%B7%B1%E5%86%99">#</a>为啥要自己写</h3><p>为什么要自己写一个RPC框架，dubbo难道满足不了你？我觉得从个人成长上说，如果一个程序员能清楚的了解RPC框架所具备的要素，掌握RPC框架中涉及的服务注册发现、负载均衡、序列化协议、RPC通信协议、Socket通信、异步调用、熔断降级等技术，可以全方位的提升基本素质。虽然也有相关源码，但是只看源码容易眼高手低，动手写一个才是自己真正掌握这门技术的最优路径。（换个角度想想dubbo真的适合你们项目吗？有多少人觉得dubbo只是比feign性能好，更主流，大公司都用等等理由才用的？）</p><h2 id="RPC框架要素"><a href="#RPC框架要素" class="headerlink" title="#RPC框架要素"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#rpc%E6%A1%86%E6%9E%B6%E8%A6%81%E7%B4%A0">#</a><strong>RPC框架要素</strong></h2><p>一款分布式RPC框架离不开三个基本要素：</p><ul><li>服务提供方 Serivce Provider</li><li>服务消费方 Servce Consumer</li><li>注册中心 Registery</li></ul><p>围绕上面三个基本要素可以进一步扩展服务路由、负载均衡、服务熔断降级、序列化协议、通信协议等等。</p><ol><li><p><strong>注册中心</strong></p><p>主要是用来完成服务注册和发现的工作。虽然服务调用是服务消费方直接发向服务提供方的，但是现在服务都是集群部署，服务的提供者数量也是动态变化的，所以服务的地址也就无法预先确定。因此如何发现这些服务就需要一个统一注册中心来承载。</p></li><li><p><strong>服务提供方（RPC服务端）</strong></p><p>其需要对外提供服务接口，它需要在应用启动时连接注册中心，将服务名及其服务元数据发往注册中心。同时需要提供服务服务下线的机制。需要维护服务名和真正服务地址映射。服务端还需要启动Socket服务监听客户端请求。</p></li><li><p><strong>服务消费方（RPC客户端）</strong></p><p>客户端需要有从注册中心获取服务的基本能力，它需要在应用启动时，扫描依赖的RPC服务，并为其生成代理调用对象，同时从注册中心拉取服务元数据存入本地缓存，然后发起监听各服务的变动做到及时更新缓存。在发起服务调用时，通过代理调用对象，从本地缓存中获取服务地址列表，然后选择一种负载均衡策略筛选出一个目标地址发起调用。调用时会对请求数据进行序列化，并采用一种约定的通信协议进行socket通信。</p></li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="#技术选型"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B">#</a><strong>技术选型</strong></h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="#注册中心"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">#</a>注册中心</h3><p>目前成熟的注册中心有Zookeeper，Nacos，Consul，Eureka，它们的主要比较如下：</p><p><img src="https://returnac.cn/images/image_uZAdaXvPwp.png" alt="img"></p><p>我们这里采用nacos</p><h3 id="IO通信框架"><a href="#IO通信框架" class="headerlink" title="#IO通信框架"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#io%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6">#</a>IO通信框架</h3><p>本实现采用Netty作为底层通信框架，Netty是一个高性能事件驱动型的非阻塞的IO(NIO)框架。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="#通信协议"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">#</a>通信协议</h3><p>TCP通信过程中会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。所以需要对发送的数据包封装到一种通信协议里。</p><p>业界的主流协议的解决方案可以归纳如下：</p><ol><li>消息定长，例如每个报文的大小为固定长度100字节，如果不够用空格补足。</li><li>在包尾特殊结束符进行分割。</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。</li></ol><p>很明显1，2都有些局限性，本实现采用方案3，<strong>自定义协议</strong></p><h3 id="序列化协议"><a href="#序列化协议" class="headerlink" title="#序列化协议"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE">#</a>序列化协议</h3><p>常见的协议有JavaSerializer、json、Protobuf及Hessian。建议选用Protobuf，其序列化后码流小性能高，非常适合RPC调用，Google自家的gRPC也是用其作为通信协议。但是我们这里采用<strong>Hessian2</strong>序列化（懒，其他后续慢慢实现）</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="#整体架构"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">#</a>整体架构</h2><p><img src="https://returnac.cn/images/image_F6p-04GZCW.png" alt="img"></p><p>下面就来看看实现吧</p><h2 id="通信相关"><a href="#通信相关" class="headerlink" title="#通信相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3">#</a>通信相关</h2><h3 id="通信协议-1"><a href="#通信协议-1" class="headerlink" title="#通信协议"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-1">#</a><strong>通信协议</strong></h3><p><img src="https://returnac.cn/images/image_O-3Mh6cCHl.png" alt="img"></p><ul><li>第一个是魔法数，比如我定义为0x01F1。</li><li>第二个代表时间戳，以便对时间进行校验</li><li>第三个是消息类型，如0代表请求1代表响应。</li><li>第四个是加密序列号，采用随机的方式对消息体加密和解密</li><li>第五个表示消息长度，即此后面的内容是消息content。</li></ul><p>对应实体类如下：</p><p><img src="https://returnac.cn/images/image_0ptwGVjIDj.png" alt="img"></p><h3 id="编码器"><a href="#编码器" class="headerlink" title="#编码器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%BC%96%E7%A0%81%E5%99%A8">#</a><strong>编码器</strong></h3><p>也就是需要按顺序写入消息的字节到缓冲器，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;RpcRemoteMsg&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, RpcRemoteMsg rpcRemoteMsg, ByteBuf out)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 写入开头的标志</span></span><br><span class="line">        out.writeShort(rpcRemoteMsg.getStartSign());</span><br><span class="line">        <span class="comment">// 写入秒时间戳</span></span><br><span class="line">        out.writeInt(rpcRemoteMsg.getTimeStamp());</span><br><span class="line">        <span class="comment">// 写消息类型</span></span><br><span class="line">        out.writeShort(rpcRemoteMsg.getMsgType());</span><br><span class="line">        <span class="comment">// 写入加密序列号</span></span><br><span class="line">        out.writeShort(rpcRemoteMsg.getEncryptSequence());</span><br><span class="line">        <span class="comment">// 写入消息长度</span></span><br><span class="line">        out.writeInt(rpcRemoteMsg.getContentLength());</span><br><span class="line">        <span class="comment">// 写入消息主体</span></span><br><span class="line">        out.writeBytes(rpcRemoteMsg.getContent());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解码器"><a href="#解码器" class="headerlink" title="#解码器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%A7%A3%E7%A0%81%E5%99%A8">#</a><strong>解码器</strong></h3><p>这里省事，直接继承<strong>LengthFieldBasedFrameDecoder</strong>实现自己逻辑，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(EasyRpcDecoder.class);</span><br><span class="line">    <span class="comment">// 开始标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">short</span> <span class="variable">HEAD_START</span> <span class="operator">=</span> (<span class="type">short</span>) <span class="number">0x01F1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> {</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength, <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip)</span> {</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength, <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip, <span class="type">boolean</span> failFast)</span> {</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip, failFast);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(ByteOrder byteOrder, <span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength, <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip, <span class="type">boolean</span> failFast)</span> {</span><br><span class="line">        <span class="built_in">super</span>(byteOrder, maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip, failFast);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 经过父解码器的处理 我们就不需要在考虑沾包和半包了</span></span><br><span class="line">        <span class="comment">// 当然，想要自己处理沾包和半包问题也不是不可以</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">decode</span> <span class="operator">=</span> (ByteBuf) <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (decode == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 开始标志校验  开始标志不匹配直接 过滤此条消息</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">startIndex</span> <span class="operator">=</span> decode.readShort();</span><br><span class="line">        <span class="keyword">if</span> (startIndex != HEAD_START) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 时间戳</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">timeStamp</span> <span class="operator">=</span> decode.readInt();</span><br><span class="line">        <span class="comment">// 请求还是响应  0：请求  1：响应</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">msgType</span> <span class="operator">=</span> decode.readShort();</span><br><span class="line">        <span class="comment">// 加密序列号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">encryptSequence</span> <span class="operator">=</span> decode.readShort();</span><br><span class="line">        <span class="comment">// 消息体长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">contentLength</span> <span class="operator">=</span> decode.readInt();</span><br><span class="line">        <span class="comment">// 读取消息</span></span><br><span class="line">        <span class="type">byte</span>[] msgByte = <span class="keyword">new</span> <span class="title class_">byte</span>[contentLength];</span><br><span class="line">        decode.readBytes(msgByte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息转成实体类 传递给下面的数据处理器</span></span><br><span class="line">        <span class="keyword">return</span> msgType == <span class="number">0</span> ? EncryptUtil.remoteMsgToRequest(encryptSequence,msgByte) : EncryptUtil.remoteMsgToResponse(encryptSequence,msgByte);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="nacos相关"><a href="#nacos相关" class="headerlink" title="#nacos相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#nacos%E7%9B%B8%E5%85%B3">#</a>nacos相关</h2><p>nacos其实很简单一共四个方法：</p><ul><li><strong>registerInstance</strong> ：注册</li><li><strong>deregisterInstance</strong> ： 下线</li><li><strong>getAllInstances</strong> ： 获取所有实例</li><li><strong>subscribe</strong> ：订阅服务</li></ul><p>我们nacos全局就一个使用类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosEasyRpcCenter</span> <span class="keyword">implements</span> <span class="title class_">EasyRpcCenter</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(NacosEasyRpcCenter.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DEFAULT_NAMESPACE</span> <span class="operator">=</span> <span class="string">"public"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DEFAULT_META_PARAM</span> <span class="operator">=</span> <span class="string">"easyRpcMeta"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NacosNamingService nacosNamingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcApplicationConfig applicationConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcCenterConfig centerConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NacosEasyRpcCenter</span><span class="params">(EasyRpcCenterConfig centerConfig, EasyRpcApplicationConfig rpcApplicationConfig)</span> {</span><br><span class="line">        Assert.isTrue(StrUtil.isNotEmpty(centerConfig.getAddress()), <span class="string">"registry address cannot be empty"</span>);</span><br><span class="line">        Assert.isTrue(StrUtil.isNotEmpty(centerConfig.getGroup()), <span class="string">"registry group cannot be empty"</span>);</span><br><span class="line">        <span class="built_in">this</span>.applicationConfig = rpcApplicationConfig;</span><br><span class="line">        <span class="built_in">this</span>.centerConfig = centerConfig;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">"serverAddr"</span>, String.format(<span class="string">"%s:%d"</span>, centerConfig.getAddress(), centerConfig.getPort()));</span><br><span class="line">        properties.setProperty(<span class="string">"namespace"</span>, StrUtil.emptyToDefault(centerConfig.getNamespace(), DEFAULT_NAMESPACE));</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="built_in">this</span>.nacosNamingService = <span class="keyword">new</span> <span class="title class_">NacosNamingService</span>(properties);</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center init error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EasyRpcRunException</span>(e.getErrMsg());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(ServiceInstance serviceInstance)</span> {</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">        instance.setIp(serviceInstance.getIp());</span><br><span class="line">        instance.setPort(serviceInstance.getPort());</span><br><span class="line">        Map&lt;String, String&gt; meteData=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        meteData.put(DEFAULT_META_PARAM,JSONObject.toJSONString(serviceInstance.getMetaDataSet()));</span><br><span class="line">        instance.setMetadata(meteData);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            nacosNamingService.registerInstance(applicationConfig.getName(), centerConfig.getGroup(),instance);</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center register error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EasyRpcRunException</span>(e.getErrMsg());</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Easy-Rpc -&gt; nacos center register:[ serviceName:{} group:{} ] success"</span>,applicationConfig.getName(),centerConfig.getGroup());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deregisterInstance</span><span class="params">(ServiceInstance serviceInstance)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            nacosNamingService.deregisterInstance(applicationConfig.getName(), centerConfig.getGroup(),serviceInstance.getIp(),serviceInstance.getPort());</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center deregister error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Easy-Rpc -&gt; nacos center deregister:[ serviceName:{} group:{} ] success"</span>,applicationConfig.getName(),centerConfig.getGroup());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title function_">getAllInstances</span><span class="params">(String serviceId)</span> {</span><br><span class="line">        List&lt;ServiceInstance&gt; serviceInstanceList = EasyRpcInstanceCache.getServiceInstanceList(serviceId);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isEmpty(serviceInstanceList)){</span><br><span class="line">            serviceInstanceList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                List&lt;Instance&gt; allInstances = nacosNamingService.getAllInstances(serviceId, centerConfig.getGroup());</span><br><span class="line">                <span class="keyword">if</span>(CollectionUtil.isNotEmpty(allInstances)){</span><br><span class="line">                    <span class="keyword">for</span>(Instance instance:allInstances){</span><br><span class="line">                        serviceInstanceList.add(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(instance.getIp(), instance.getPort()));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">                log.error(<span class="string">"Easy-Rpc -&gt; nacos center deregister error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">            }</span><br><span class="line">            EasyRpcInstanceCache.updateServiceInstanceInfo(serviceId,serviceInstanceList);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> serviceInstanceList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeInstance</span><span class="params">(String serviceId)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            nacosNamingService.subscribe(serviceId, centerConfig.getGroup(), <span class="keyword">new</span> <span class="title class_">AbstractEventListener</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> {</span><br><span class="line">                    <span class="keyword">return</span> ThreadPoolUtils.subscribeInstancePool;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> {</span><br><span class="line">                    <span class="type">NamingEvent</span> <span class="variable">namingEvent</span> <span class="operator">=</span> (NamingEvent) event;</span><br><span class="line">                    List&lt;Instance&gt; allInstances = namingEvent.getInstances();</span><br><span class="line">                    List&lt;ServiceInstance&gt; serviceInstanceList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">                    <span class="keyword">if</span>(CollectionUtil.isNotEmpty(allInstances)){</span><br><span class="line">                        <span class="keyword">for</span>(Instance instance:allInstances){</span><br><span class="line">                            serviceInstanceList.add(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(instance.getIp(), instance.getPort()));</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 直接把本地的全量替换</span></span><br><span class="line">                    EasyRpcInstanceCache.updateServiceInstanceInfo(serviceId,serviceInstanceList);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center subscribe error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Easy-Rpc -&gt; nacos center subscribe:[{}] success"</span>,serviceId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="消费者相关"><a href="#消费者相关" class="headerlink" title="#消费者相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%B8%E5%85%B3">#</a>消费者相关</h2><p>消费者不用想，凡是这种RPC的几乎都是动态代理，问题是用什么样的方法为它生成代理，我们以Feign为例看看它是怎么做的？</p><p><strong>启动注解→扫描包下被注解标识的接口→获取封装信息→生成FeignClientFactoryBean注入容器</strong></p><p><img src="https://returnac.cn/images/image_CslT48jUM2.png" alt="img"></p><p>感兴趣的可以自己去看看，最终我们采用注解调用时，获取的无非是<strong>factoryBean.getObject();</strong> 返回的动态代理对象罢了</p><p>想想这样合适吗？<strong>他需要扫描整个包然后生成代理对象再放入容器，要是这个对象压根没人用岂不是白生成了？</strong> 所以我这里改了一下，不再扫描包生成了，<strong>我在你属性注入时才生成！</strong></p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="#自定义注解"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">#</a>自定义注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target({ElementType.FIELD})</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EasyRpcServiceInvoke {</span><br><span class="line">    <span class="comment">// 服务项ID</span></span><br><span class="line">    String <span class="title function_">serviceId</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 服务发布的Bean 名称</span></span><br><span class="line">    String <span class="title function_">beanRefName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此注解代表我需要获取远程调用的代理对象，如：</p><p><img src="https://returnac.cn/images/image_yXBIfqLXL9.png" alt="img"></p><h3 id="消费者后置处理器"><a href="#消费者后置处理器" class="headerlink" title="#消费者后置处理器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8">#</a>消费者后置处理器</h3><p>所以我要在Bean属性注入的时候，为它注入一个动态代理对象，同时添加需要订阅的服务项</p><p>这个服务项在Nacos中就是服务名，就好比feign也需要指定一个服务名是吧</p><p><img src="https://returnac.cn/images/image_a_G9shqtad.png" alt="img"></p><p>为什么dubbo不需要？因为dubbo在nacos不是以服务为单位，而是以暴露的接口服务为单位，如下：</p><p><img src="https://returnac.cn/images/image_L3v3aEw_yv.png" alt="img"></p><h3 id="代理对象生成"><a href="#代理对象生成" class="headerlink" title="#代理对象生成"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90">#</a>代理对象生成</h3><p>这里采用了Cglib动态代理，为什么不用jdk动态代理，主要是为了避免反射耗时，也方便以后拓展的灵活性</p><p><strong>代理工厂：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibInvokeBeanProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> colins</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  获取客户端远程调用代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getClientInvokeProxy</span><span class="params">(Class&lt;T&gt; interfaceClass, String serviceId, String beanRef,String interfaces)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(interfaceClass, <span class="keyword">new</span> <span class="title class_">CglibInvocationHandler</span>(serviceId, beanRef,interfaces));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代理处理类：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanRef;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibInvocationHandler</span><span class="params">(String serviceId, String beanRef, String interfaces)</span> {</span><br><span class="line">        <span class="built_in">this</span>.serviceId = serviceId;</span><br><span class="line">        <span class="built_in">this</span>.beanRef = beanRef;</span><br><span class="line">        <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        List&lt;ServiceInstance&gt; serviceInstanceList = EasyRpcInstanceCache.getServiceInstanceList(serviceId);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(serviceInstanceList)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EasyRpcException</span>(String.format(<span class="string">"[ %d ] No corresponding service found "</span>, serviceId));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建请求参数</span></span><br><span class="line">        <span class="type">EasyRpcRequest</span> <span class="variable">easyRpcRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyRpcRequest</span>(UUID.randomUUID().toString(),beanRef, interfaces, method.getName(), method.getParameterTypes(), objects);</span><br><span class="line">        <span class="comment">// 获取会话</span></span><br><span class="line">        <span class="type">EasyRpcSession</span> <span class="variable">easyRpcSession</span> <span class="operator">=</span> EasyRpcSessionFactory.getInstance().openSession(serviceId, easyRpcRequest, serviceInstanceList);</span><br><span class="line">        <span class="comment">// 会话执行调用</span></span><br><span class="line">        <span class="keyword">return</span> easyRpcSession.exec();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="生产者相关"><a href="#生产者相关" class="headerlink" title="#生产者相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%94%9F%E4%BA%A7%E8%80%85%E7%9B%B8%E5%85%B3">#</a>生产者相关</h2><h3 id="自定义注解-1"><a href="#自定义注解-1" class="headerlink" title="#自定义注解"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-1">#</a>自定义注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target({ElementType.TYPE})</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EasyRpcServicePublish {</span><br><span class="line">    <span class="comment">// 暴露出去的bean名称 默认就是bean默认名称</span></span><br><span class="line">    String <span class="title function_">beanRefName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="生产者后置处理器"><a href="#生产者后置处理器" class="headerlink" title="#生产者后置处理器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%94%9F%E4%BA%A7%E8%80%85%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8">#</a>生产者后置处理器</h3><p>主要两件事：</p><ul><li>收集暴露出去的bean集合</li><li>收集需要暴露出去的元数据</li></ul><p><img src="https://returnac.cn/images/image_s3siw1oxfY.png" alt="img"></p><p><strong>为什么要收集暴露出去的服务bean？</strong></p><p>仔细看一下上面的注解是一个复合注解，我暴露出去提供远程调用服务的对象在容器中不就是一个bean吗？<strong>所以如果有消费者调用暴露的服务，本质不就是调用远程容器中的bean对象吗？</strong> 所以我给它收集缓存起来，要是有别的服务远程调用过来，我直接走缓存反射执行方法就好了</p><h2 id="容器相关"><a href="#容器相关" class="headerlink" title="#容器相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3">#</a>容器相关</h2><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="#容器启动"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8">#</a>容器启动</h3><p>需要做三件事，启动netty server 、发布服务、订阅服务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcStartEvent</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcConfig rpcConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcCenter rpcCenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcStartEvent</span><span class="params">(EasyRpcConfig rpcConfig, EasyRpcCenter rpcCenter)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rpcConfig = rpcConfig;</span><br><span class="line">        <span class="built_in">this</span>.rpcCenter = rpcCenter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> {</span><br><span class="line">        <span class="comment">// 启动NettyServer</span></span><br><span class="line">        ThreadPoolUtils.startNettyPool.execute(<span class="keyword">new</span> <span class="title class_">EasyRpcServer</span>(rpcConfig.getProtocol().getPort(), <span class="keyword">new</span> <span class="title class_">EasyRpcServerHandlerInit</span>()));</span><br><span class="line">        <span class="comment">// 发布服务</span></span><br><span class="line">        rpcCenter.registerInstance(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(rpcConfig.getProtocol().getPort(), EasyRpcSpringConstant.serviceMetaDataList));</span><br><span class="line">        <span class="comment">// 订阅服务</span></span><br><span class="line">        EasyRpcSpringConstant.serviceIdList.forEach(item-&gt;{</span><br><span class="line">            rpcCenter.subscribeInstance(item);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="容器关闭"><a href="#容器关闭" class="headerlink" title="#容器关闭"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%AE%B9%E5%99%A8%E5%85%B3%E9%97%AD">#</a>容器关闭</h3><p>只需要让该服务注册下线即可，如果想优雅一点，可以把Netty相关也全关闭（这里先不处理）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcCloseEvent</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextClosedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcConfig rpcConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcCenter rpcCenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcCloseEvent</span><span class="params">(EasyRpcConfig rpcConfig, EasyRpcCenter rpcCenter)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rpcConfig = rpcConfig;</span><br><span class="line">        <span class="built_in">this</span>.rpcCenter = rpcCenter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> {</span><br><span class="line">        <span class="comment">// 注销服务即可 其他中断无所谓</span></span><br><span class="line">        <span class="comment">// netty server下线 client会断开重连</span></span><br><span class="line">        rpcCenter.deregisterInstance(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(rpcConfig.getProtocol().getPort()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调用相关"><a href="#调用相关" class="headerlink" title="#调用相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3">#</a>调用相关</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="#消费者"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B6%88%E8%B4%B9%E8%80%85">#</a>消费者</h3><p>消费者在调用的时候本质是执行代理对象中的逻辑，也就是往netty管道中写入数据，不在多说，看看发送数据的实体类</p><p><img src="https://returnac.cn/images/image_UtLgkSMMy5.png" alt="img"></p><h3 id="生产者"><a href="#生产者" class="headerlink" title="#生产者"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%94%9F%E4%BA%A7%E8%80%85">#</a>生产者</h3><p>生产者就是根据传来的信息，拿到缓存中对象的bean对象反射执行方法，然后返回</p><p><img src="https://returnac.cn/images/image_j9vfUh55Go.png" alt="img"></p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="#测试结果"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C">#</a>测试结果</h2><p>消费端16线程，所以均为一台机器(生产、消费、jmeter都在一台机器)</p><p><strong>测试结果仅供参考，在好的条件下，某些配置设置合适点，吞吐量应该更高</strong></p><table><thead><tr><th></th><th>无传参 无返回</th><th>POJO传参 简单返回</th><th>简单传参 POJO返回</th><th>无传参 POJO_list返回</th></tr></thead><tbody><tr><td>100并发 1000次请求 （共计10000）</td><td>1W左右QPS</td><td>9350左右QPS</td><td>8900左右QPS</td><td>7500左右QPS</td></tr><tr><td>300并发 1000次请求 （共计30000）</td><td>9200左右QPS</td><td>8700左右QPS</td><td>8000左右QPS</td><td>6800左右QPS</td></tr><tr><td>500并发 1000次请求 （共计50000）</td><td>8500左右QPS</td><td>7800左右QPS</td><td>7800左右QPS</td><td>6800左右QPS</td></tr></tbody></table><h2 id="后续拓展"><a href="#后续拓展" class="headerlink" title="#后续拓展"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%90%8E%E7%BB%AD%E6%8B%93%E5%B1%95">#</a>后续拓展</h2><p>从以上可以看到很多东西都还没实现，只能说基本雏形搭完了，后续什么SPI机制、服务治理相关、多协议拓展、配置丰富化、多注册中心等等都是可以做的事，最后再看一下架构吧</p><p><img src="https://returnac.cn/images/image_F6p-04GZCW.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
