<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程序是怎样跑起来的</title>
      <link href="/2024/05/31/cheng-xu-shi-zen-yang-pao-qi-lai-de/"/>
      <url>/2024/05/31/cheng-xu-shi-zen-yang-pao-qi-lai-de/</url>
      
        <content type="html"><![CDATA[<p>主要要求：机器语言程序被加载到内存，然后由CPU进行解释和执行，从而完成对计算机系统的控制和数据运算等任务。</p><h2 id="1-CPU是什么？"><a href="#1-CPU是什么？" class="headerlink" title="1.CPU是什么？"></a>1.CPU是什么？</h2><p>CPU是计算机的大脑，由数百万至数亿个晶体管构成，是负责对最终转换成机器语言的程序内容进行解释和执行的设备。</p><p>问题： </p><p>1.什么是程序？计算机每一步动作的一组指令</p><p>2.程序由什么组成？ 数据与指令</p><p>3.什么是机器语言？ CPU可以直接执行解释的语言</p><p>4.运行中的程序存放在什么地方？ 内存</p><p>5.什么是内存地址？ 表示数据与指令在内存中的位置的数值</p><p>6.在计算机的组成部件中，负责对程序进行解释和运行的是哪个？</p><p>CPU</p><h3 id="1-1-CPU的内部构造"><a href="#1-1-CPU的内部构造" class="headerlink" title="1.1 CPU的内部构造"></a>1.1 CPU的内部构造</h3><p>CPU本质是名为集成电路的电子部件，由大量晶体管组成。</p><p>从功能上看：CPU由寄存器、控制器、运算器和时钟组成。如图1.1所示</p><p>![屏幕截图 2024-05-31 220019](D:\Lenovo\source_posts\程序是怎样跑起来的\屏幕截图 2024-05-31 220019.png)</p><p>其中，<strong>寄存器</strong>存放指令、数据；控制器负责将内存中的指令和数据读入寄存器，并根据指令的执行结果对计算机进行控制；<strong>运算器</strong>负责运算从内存中读入寄存器的数据；<strong>时钟</strong>负责产生控制CPU工作节律的时钟信号。</p><p>通常所说的内存是指<strong>主存储器</strong>，简称主存。内存由一些可读写的存储元件构成，每个字节都分配了一个被称为地址的编号。CPU通过地址就可以读取内存中的指令和数据，也可以将数据写入内存，关闭计算机后，内存中的数据和指令就会消失。</p><p>程序运行原理：</p><p>当程序起点时，CPU中的控制器根据时钟信号从内存中读取指令和数据。然后运算器根据指令对数据进行运算，控制器根据运算结果控制计算机进行指定的操作。</p><h3 id="1-2CPU是寄存器的集合体"><a href="#1-2CPU是寄存器的集合体" class="headerlink" title="1.2CPU是寄存器的集合体"></a>1.2CPU是寄存器的集合体</h3><p>将汇编语言转换为机器语言的过程是汇编。反之，则反汇编。</p><p>代码清单1-1</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov1 -4(%ebp), %eax  # 将内存中的值读入eax</span><br><span class="line">add1 -8(%ebp), %eax  # 将内存中的值累加到eax</span><br><span class="line">mov1 %eax, -12(%ebp) # 将eax中的值存入到内存中</span><br></pre></td></tr></tbody></table></figure><p>代码清单1-1中，eax和ebp都代表CPU内部寄存器的名称。</p><p>CPU类型不同，则内部的寄存器数量、类型及寄存器中能存储的数据长度也有所不同。</p><p>表1-1 寄存器的主要类型及其功能</p><table><thead><tr><th>寄存器的类型</th><th>功能</th></tr></thead><tbody><tr><td>累加器</td><td>存放执行运算的数据和运算结果</td></tr><tr><td>标志寄存器</td><td>存放运算处理后的CPU状态</td></tr><tr><td>程序计数器</td><td>存放下一条指令所在内存的地址</td></tr><tr><td>基址寄存器</td><td>存放数据内存的起始地址</td></tr><tr><td>变址寄存器</td><td>存放基址寄存器的相对地址</td></tr><tr><td>通用寄存器</td><td>存放任意数据</td></tr><tr><td>指令寄存器</td><td>存放指令。程序员不能通过程序读取它的值</td></tr><tr><td>栈寄存器</td><td>存放栈空间的起始地址</td></tr></tbody></table><p>在代码清单1-1中，eax就是累加器，ebp就是基址寄存器。</p><p>一般来说，程序计数器，累加器、标志寄存器、指令寄存器、栈寄存器各仅有一个，其它类型可以由多个。</p><p>条件、循环：</p><p>CPU会根据标准寄存器的结果来判断是否执行跳转指令。</p><p>比较方式：判断累加器的值XXX和通用寄存器中的值YYY，</p><p>就是执行XXX-YYY。若为正数，则标志寄存器后三位为001；为零则为010；为负数则为100</p><p>函数调用：</p><p>在执行call指令之前，会将程序计数器中的地址存放在栈中，当调用函数执行完毕后，就会把栈中的地址return给程序计数器</p><h3 id="1-3-用基址和变址实现数组"><a href="#1-3-用基址和变址实现数组" class="headerlink" title="1.3 用基址和变址实现数组"></a>1.3 用基址和变址实现数组</h3><p>基址寄存器存储的是数组的起始地址，变址寄存器存储的值相当于数组的下标。</p><p>比如，访问地址10000000-1000FFFF时，基址寄存器存储10000000，变址寄存器可以存储00000000-0000FFFF范围内的值，CPU就会将两个值相加得出真实地址值</p><h3 id="1-4-CPU的功能指令表"><a href="#1-4-CPU的功能指令表" class="headerlink" title="1.4 CPU的功能指令表"></a>1.4 CPU的功能指令表</h3><table><thead><tr><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>数据床送指令</td><td>在寄存器和内存，内存和内存，以及寄存器和外部设备之间读写数据</td></tr><tr><td>运算指令</td><td>用累加器执行算数运算、逻辑运算、比较运算、移位运算等操作</td></tr><tr><td>跳转指令</td><td>执行条件分支、循环和无条件跳转</td></tr><tr><td>调用/返回指令</td><td>调用函数/返回函数调用处</td></tr></tbody></table><p>外部设备是指连接到计算机上的键盘、鼠标、显示器、磁盘、打印机等。</p><h2 id="2-用二进制来理解数据"><a href="#2-用二进制来理解数据" class="headerlink" title="2.用二进制来理解数据"></a>2.用二进制来理解数据</h2><p>问：</p><ol><li><p>32比特是多少字节？4字节</p></li><li><p>二进制01011100用十进制表示是多少？92</p></li><li><p>二进制数00001111左移2位，得到的结果是原数的多少倍？ 4倍</p></li><li><p>以2的补码形式表示的8位二进制数11111111用十进制表示是多少？-1</p></li><li><p>以2的补码形式表示的8位二进制数10101010用16位二进制表示是多少？ 1111 1111 1010 1010</p></li><li><p>要反转图案中的一部分点，应该使用哪种逻辑运算？</p></li></ol><p>​        逻辑异或运算</p><p>逻辑异或会将所有与1对应的位反转，逻辑非会将所有的位反转。</p><h3 id="2-1-计算机用二进制处理信息的原因"><a href="#2-1-计算机用二进制处理信息的原因" class="headerlink" title="2.1 计算机用二进制处理信息的原因"></a>2.1 计算机用二进制处理信息的原因</h3><p>计算机内部是由集成电路的电子元件构成，集成电路的每根引脚只能有两种状态。</p><p>在计算机中，比特是最小单位，字节是基本单位。内存和硬盘中，数据以字节为单位进行存储，也以字节为单位进行读写的</p><h3 id="2-2-二进制是什么"><a href="#2-2-二进制是什么" class="headerlink" title="2.2 二进制是什么"></a>2.2 二进制是什么</h3><p>二进制代表的是以2为基数来计数的。</p><h3 id="2-3-移位运算与乘除运算的关系"><a href="#2-3-移位运算与乘除运算的关系" class="headerlink" title="2.3 移位运算与乘除运算的关系"></a>2.3 移位运算与乘除运算的关系</h3><p>左移代表在原数的基础上进行乘运算，右移代表的是除运算。</p><h3 id="2-4便于计算机处理的”2的补码“"><a href="#2-4便于计算机处理的”2的补码“" class="headerlink" title="2.4便于计算机处理的”2的补码“"></a>2.4便于计算机处理的”2的补码“</h3><p>为什么要有补码，就是因为计算机只有加法器。</p><p>补码的反码+1就是原码。</p><p>正数的原码，反码，补码都一样</p><h3 id="2-5-逻辑右移与算术右移的区别"><a href="#2-5-逻辑右移与算术右移的区别" class="headerlink" title="2.5 逻辑右移与算术右移的区别"></a>2.5 逻辑右移与算术右移的区别</h3><p>逻辑右移：高位填充0，倍数不是原来的几分之几了</p><p>算术右移：高位用符号位进行填充。</p><p>符号扩展：就是将一个8位的二进制数转为16位或32位二进制数。 只需要使用符号位的值进行高位填充</p><h2 id="3-计算机在计算小数时会出错的原因"><a href="#3-计算机在计算小数时会出错的原因" class="headerlink" title="3.计算机在计算小数时会出错的原因"></a>3.计算机在计算小数时会出错的原因</h2><h3 id="3-1-将0-1累加100次的结果不是10"><a href="#3-1-将0-1累加100次的结果不是10" class="headerlink" title="3.1 将0.1累加100次的结果不是10"></a>3.1 将0.1累加100次的结果不是10</h3><p>使用C语言会得到结果为10.000002</p><h3 id="3-2-如何用二进制表示小数"><a href="#3-2-如何用二进制表示小数" class="headerlink" title="3.2 如何用二进制表示小数"></a>3.2 如何用二进制表示小数</h3><p>使用小数部分×位权</p><h3 id="3-3-计算机出错原因"><a href="#3-3-计算机出错原因" class="headerlink" title="3.3 计算机出错原因"></a>3.3 计算机出错原因</h3><p>某些十进制小数无法准确的转换成二进制数</p><h3 id="3-4-什么是浮点数？"><a href="#3-4-什么是浮点数？" class="headerlink" title="3.4 什么是浮点数？"></a>3.4 什么是浮点数？</h3><p>浮点数将小数分为符号、尾数、基数和指数四个部分来表示。</p><p><img src="D:\Lenovo\source_posts\程序是怎样跑起来的\浮点数.png"></p><p>很多编程语言中都提供了两种表示小数的数据类型，分别是<strong>双精度浮点数</strong>和<strong>单精度浮点数</strong>。双精度浮点数类型用 64 位、单精度浮点数类型用 32 位来表示全体小数。在 C 语言中，双精度浮点数类型和单精度浮点数类型分别用 double 和 float 来表示。</p><p><img src="D:\Lenovo\source_posts\程序是怎样跑起来的\浮点数内部构造.png" alt="浮点数内部构造"></p><p>尾数部分和指数部分并不只是单单存储着用整数表示的二进制数。尾数部分用的是“将小数点前面的值固定为 1 的规格化表示法，而指数部分用的则是“移码（excess）表示法”。指数位越多，尾数位则越少，其表示的范围越大，但精度就会变差，反之，指数位越少，尾数位则越多，表示的范围越小，但精度就会变好。</p><h3 id="3-5-规格化表示法-和-移码表示法"><a href="#3-5-规格化表示法-和-移码表示法" class="headerlink" title="3.5 规格化表示法 和 移码表示法"></a>3.5 规格化表示法 和 移码表示法</h3><p>尾数使用规格化表示法</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1011.0011        ...原数</span><br><span class="line">1.0110011        ...右移使得正数部分的第1位为1</span><br><span class="line">1.01100110000000000000000  ... 将小数部分扩展至23位</span><br><span class="line">01100110000000000000000    ... 只保留小数部分，完成规格化表示</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>、</p><p>指数使用移码表示法</p><table><thead><tr><th>实际值（二进制）</th><th>实际值（十进制）</th><th>移码表示法中的对应值（十进制）</th></tr></thead><tbody><tr><td>11111111</td><td>255</td><td>128（255-127）</td></tr><tr><td>11111110</td><td>254</td><td>127（254-127）</td></tr><tr><td>….</td><td>….</td><td>…</td></tr><tr><td>01111111</td><td>127</td><td>0</td></tr><tr><td>01111110</td><td>126</td><td>-1</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>00000001</td><td>1</td><td>-126</td></tr><tr><td>00000000</td><td>0</td><td>-127</td></tr></tbody></table><h3 id="3-6-如何避免计算机出错"><a href="#3-6-如何避免计算机出错" class="headerlink" title="3.6 如何避免计算机出错"></a>3.6 如何避免计算机出错</h3><p>回避策略与使用正数代替小数。</p><p>BCD就是一种使用正数代替小数的格式</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/02/29/dong-tai-gui-hua/"/>
      <url>/2024/02/29/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2024/02/29/tan-xin-suan-fa/"/>
      <url>/2024/02/29/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2024/02/29/hui-su-suan-fa/"/>
      <url>/2024/02/29/hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/02/29/er-cha-shu/"/>
      <url>/2024/02/29/er-cha-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2024/02/29/zhan-yu-dui-lie/"/>
      <url>/2024/02/29/zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2024/02/29/zi-fu-chuan/"/>
      <url>/2024/02/29/zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/02/28/hello-world/"/>
      <url>/2024/02/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2024/02/26/lian-biao/"/>
      <url>/2024/02/26/lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="1-链表的概念"><a href="#1-链表的概念" class="headerlink" title="1.链表的概念"></a>1.链表的概念</h2><p>链表是一种通过指针串联在一起的线性结构。</p><p>每一个节点由两部分组成：数据域，指针域</p><p>链表的入口称为头节点，及head</p><h3 id="1-1链表的类型"><a href="#1-1链表的类型" class="headerlink" title="1.1链表的类型"></a>1.1链表的类型</h3><ul><li>单链表</li><li>双链表</li><li>循环链表</li></ul><h3 id="1-2链表节点的定义"><a href="#1-2链表节点的定义" class="headerlink" title="1.2链表节点的定义"></a>1.2链表节点的定义</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>{</span><br><span class="line">        <span class="built_in">this</span>.val =val;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(ListNode next)</span>{</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-链表的操作"><a href="#1-3-链表的操作" class="headerlink" title="1.3 链表的操作"></a>1.3 链表的操作</h3><h4 id="1-3-1删除节点"><a href="#1-3-1删除节点" class="headerlink" title="1.3.1删除节点"></a>1.3.1删除节点</h4><p>将要删除的前一个节点的指针指向删除节点指针指向的节点</p><p><img src="C:\Users\启明\AppData\Roaming\Typora\typora-user-images\image-20240226180558619.png" alt="image-20240226180558619"></p><h4 id="1-3-2添加节点"><a href="#1-3-2添加节点" class="headerlink" title="1.3.2添加节点"></a>1.3.2添加节点</h4><p>将要添加节点的位置的那个节点A的指针指向要添加的这个节点B，这个节点B的指针指向A节点指针原来指向的那个节点C</p><p><img src="C:\Users\启明\AppData\Roaming\Typora\typora-user-images\image-20240226180709032.png" alt="image-20240226180709032"></p><h3 id="1-4-善于利用虚拟头节点"><a href="#1-4-善于利用虚拟头节点" class="headerlink" title="1.4 善于利用虚拟头节点"></a>1.4 善于利用虚拟头节点</h3><h2 id="2-力扣"><a href="#2-力扣" class="headerlink" title="2.力扣"></a>2.力扣</h2><h3 id="2-1-设计链表"><a href="#2-1-设计链表" class="headerlink" title="2.1 设计链表"></a>2.1 设计链表</h3><p><strong>【题目描述】</strong></p><p>设计一个链表类，实现六个接口：</p><ul><li>获取链表的第index节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表的第index节点前面插入一个节点</li><li>删除链表的第index节点</li><li>打印当前链表</li></ul><p>注意：index从0开始</p><p>力扣 <a href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList {</span><br><span class="line">private LinkedNode virtualHead;</span><br><span class="line"></span><br><span class="line">    public MyLinkedList() {</span><br><span class="line">virtualHead = new LinkedNode(0);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public int get(int index) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void addAtHead(int val) {</span><br><span class="line">LinkedNode next = virtualHead.next;</span><br><span class="line">new LinkedNode </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void addAtTail(int val) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void addAtIndex(int index, int val) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void deleteAtIndex(int index) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-反转链表"><a href="#2-2-反转链表" class="headerlink" title="2.2 反转链表"></a>2.2 反转链表</h3><p><strong>【题目描述】</strong></p><p>反转一个单链表。要求是不能申请额外的内存空间</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><h4 id="2-2-1双指针法"><a href="#2-2-1双指针法" class="headerlink" title="2.2.1双指针法"></a>2.2.1双指针法</h4><p>cur指针指向头节点，</p><p>pre指针，初始为null，</p><p>temp指针保存cur的下一个节点</p><p><img src="C:\Users\启明\AppData\Roaming\Typora\typora-user-images\image-20240226210022695.png" alt="image-20240226210022695"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-2-2-递归法"><a href="#2-2-2-递归法" class="headerlink" title="2.2.2 递归法"></a>2.2.2 递归法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre, ListNode cur)</span> {</span><br><span class="line"><span class="keyword">if</span>(cur==<span class="literal">null</span>){</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">}</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>{</span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">null</span>,head);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-删除倒数第n个节点"><a href="#2-3-删除倒数第n个节点" class="headerlink" title="2.3 删除倒数第n个节点"></a>2.3 删除倒数第n个节点</h3><p><strong>【题目描述】</strong></p><p>删除链表中倒数第n个节点（n从1开始）</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><p>双指针法+虚拟头节点</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span> &amp;&amp; fast!=<span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// fast 指针移动 n步</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(fast.next!=<span class="literal">null</span>){</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow =slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 找到要删除的节点的前一个一个节点slow</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为什么是返回这个而不是head ?</span></span><br><span class="line">    <span class="comment">// 如果刚好删除的是head,则返回head就只是一个节点</span></span><br><span class="line">    <span class="comment">// 而dummyHead.next才是一个链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-环形链表"><a href="#2-4-环形链表" class="headerlink" title="2.4 环形链表"></a>2.4 环形链表</h3><p><strong>【题目描述】</strong></p><p>判断一个链表是否有环，如果有环，则找到入环的第一个节点，如果无环，则返回null</p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></p><h4 id="2-4-1判断链表是否有环"><a href="#2-4-1判断链表是否有环" class="headerlink" title="2.4.1判断链表是否有环"></a>2.4.1判断链表是否有环</h4><p>双指针判断，fast指针一次走两步，slow指针一次走一步，如果存在fast= slow，则代表有环</p><h4 id="2-4-2-寻找环的入口"><a href="#2-4-2-寻找环的入口" class="headerlink" title="2.4.2 寻找环的入口"></a>2.4.2 寻找环的入口</h4><p>x代表从头节点到入口节点的距离，y代表从入口节点到相遇节点的距离，Z代表从相遇节点到入口节点的距离</p><p>fast节点比slow节点快，相遇时，slow节点一定是还未转一圈。</p><p>为什么呢？</p><p>如果slow节点已经转一圈了，因为fast相对于slow每次走一步，那么此时fast转了两圈，他们应该相遇两次了</p><p>所有有 slow = x+y, fast = x+y+n(z+y)</p><p>2(x+y) = x+y+n(z+y);</p><p>即是 x = (n-1)(z+y)+z;</p><p>如果只转了一圈， 则 x=z, 如果两个指针同时从头节点和相遇节点出发，则，他们相遇时的节点就是入口节点。</p><p>如果n&gt;1,结果也是一样</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>){</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇</span></span><br><span class="line">        <span class="keyword">if</span>(slow==fast){</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> fast;</span><br><span class="line">            <span class="keyword">while</span>(index1!=index2){</span><br><span class="line">                index1 = index1.next;</span><br><span class="line">                index2 = index2.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2024/02/26/shu-zu/"/>
      <url>/2024/02/26/shu-zu/</url>
      
        <content type="html"><![CDATA[<p>s</p><h2 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1. 数组的概念"></a>1. 数组的概念</h2><p>数组是存储在连续内存空间上相同类型数据的集合。</p><p>Java中一维数组内存连续，二维数组中的元素为一维数组，一维数组是连续的，但元素与元素之间的内存地址不一定连续</p><p>在Java中，可以使用<code>System.identityHashCode()</code>方法来获取对象（包括数组）的内存地址。该方法返回一个32位的哈希值，但并不能直接表示真正的内存地址。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMemoryAddress</span><span class="params">(<span class="type">int</span>[] arr)</span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">memoryAddress</span> <span class="operator">=</span> System.identityHashCode(element);</span><br><span class="line">            System.out.println(<span class="string">"Element "</span>+element+ <span class="string">"  memoryAddress "</span>+memoryAddress);</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-1二分查找"><a href="#1-1二分查找" class="headerlink" title="1.1二分查找"></a>1.1二分查找</h3><p>二分查找的前提是数组是有序的且无重复元素。</p><p><strong>【题目描述】</strong></p><p>在一个有序且无重复元素的数组nums中，寻找一个元素target,如果找到，返回对应下标，没有返回-1</p><p>力扣 <a href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></p><p>主要问题：边界条件</p><h4 id="1-1-1左闭右闭-left-right"><a href="#1-1-1左闭右闭-left-right" class="headerlink" title="1.1.1左闭右闭[left,right]"></a>1.1.1左闭右闭[left,right]</h4><p>定义target在一个[] 区间</p><ul><li>那left与right相等的情况在区间是有意义的，所以while(left&lt;=right)</li><li>如果nums[mid] &gt; target, 则需要更新搜索范围右下标为mid-1</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt; target){</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-1-2左开右闭-left-right"><a href="#1-1-2左开右闭-left-right" class="headerlink" title="1.1.2左开右闭[left,right]"></a>1.1.2左开右闭[left,right]</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right){</span><br><span class="line">            middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target){</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target){</span><br><span class="line">                right = middle;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-移除元素"><a href="#1-2-移除元素" class="headerlink" title="1.2 移除元素"></a>1.2 移除元素</h3><p><strong>【题目描述】</strong></p><p>原地移除数组中所有等于val的元素，要求不能使用额外的辅助空间，及空间复杂度为O(1),返回移除元素后的新数组的size</p><p>力扣 <a href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></p><h4 id="1-2-1暴力解法"><a href="#1-2-1暴力解法" class="headerlink" title="1.2.1暴力解法"></a>1.2.1暴力解法</h4><p>双重循环，第一重循环寻找 val, 第二重循环覆盖</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> val)</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++){</span><br><span class="line">         <span class="keyword">if</span>(arr[i] == val){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size ; j++){</span><br><span class="line">                arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">            }</span><br><span class="line">            i-- ;</span><br><span class="line">            size --;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2-2双指针法（快慢指针法）"><a href="#1-2-2双指针法（快慢指针法）" class="headerlink" title="1.2.2双指针法（快慢指针法）"></a>1.2.2双指针法（快慢指针法）</h4><p><strong>双指针法（快慢指针法）</strong>：通过一个快指针和慢指针在一个for循环内完成两个for循环的工作</p><p>快慢指针同时自增，条件满足时，都会将fastIndex下标的赋值给 slowIndex下标的数，条件不满足时，slowindex就不会增加，此时双指针错位</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span>{</span><br><span class="line"><span class="comment">// 定义两个指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;fastIndex &lt; nums.length ; fastIndex++){</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != val){</span><br><span class="line">            nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-长度最小的子数组"><a href="#1-3-长度最小的子数组" class="headerlink" title="1.3 长度最小的子数组"></a>1.3 长度最小的子数组</h3><p><strong>【题目描述】</strong></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><h4 id="1-3-1暴力解法"><a href="#1-3-1暴力解法" class="headerlink" title="1.3.1暴力解法"></a>1.3.1暴力解法</h4><p>双重循环，第一重循环获取i,代表从i开始的第二重循环</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> nums[])</span>{</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++){</span><br><span class="line">            sum = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &lt; nums.length ; j++){</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target) {</span><br><span class="line">                    length = j-i+<span class="number">1</span>;</span><br><span class="line">                    result = result &lt; length ?result:length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result==Integer.MAX_VALUE? <span class="number">0</span>:result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-3-2滑动窗口"><a href="#1-3-2滑动窗口" class="headerlink" title="1.3.2滑动窗口"></a>1.3.2滑动窗口</h4><p>滑动窗口： 就是不断地调节子数组的起始位置和终止位置。</p><p>两个指针：指针之间中的部分是窗口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> nums[])</span>{</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起始指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 终止指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;end&lt; nums.length;end++){</span><br><span class="line">        sum += nums[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 滑动窗口的精髓</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target){</span><br><span class="line">            <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> end -start +<span class="number">1</span>;</span><br><span class="line">            result = result &lt; subLength ? result: subLength;</span><br><span class="line">            sum = sum - nums[start] ;</span><br><span class="line">            start ++ ; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result==Integer.MAX_VALUE? <span class="number">0</span>:result;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-螺旋矩阵II"><a href="#1-4-螺旋矩阵II" class="headerlink" title="1.4 螺旋矩阵II"></a>1.4 螺旋矩阵II</h3><p><strong>【题目描述】</strong></p><p>给出一个正整数n,按从外向内的螺旋顺序打印1到n^2的所有数值</p><p><strong>螺旋不变量</strong></p><p>即按照左闭右开或左开右闭的原则，有一定规则的“画”下来</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 每循环一圈的起始位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环的圈数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> n /<span class="number">2</span> ;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">// 循环一圈后的偏移量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 中心位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> n/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(loop--&gt;<span class="number">0</span>){</span><br><span class="line">        i = x;</span><br><span class="line">        j = y;</span><br><span class="line">        <span class="comment">// 从左向右填充</span></span><br><span class="line">        <span class="keyword">for</span>(j=y;j&lt;y+n-offset;j++){</span><br><span class="line">            res[x][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从上到下填充</span></span><br><span class="line">         <span class="keyword">for</span>(i=x;i&lt;x+n-offset;i++){</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从右到左填充</span></span><br><span class="line">         <span class="keyword">for</span>(;j&gt;y;j--){</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从下到上填充</span></span><br><span class="line">         <span class="keyword">for</span>(;i&gt;x;i--){</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 起始位置发生改变</span></span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 偏移量发生改变</span></span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>){</span><br><span class="line">        res[mid][mid] = n*n ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序的性能分析</title>
      <link href="/2024/02/26/cheng-xu-de-xing-neng-fen-xi/"/>
      <url>/2024/02/26/cheng-xu-de-xing-neng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-时间复杂度分析"><a href="#1-时间复杂度分析" class="headerlink" title="1.时间复杂度分析"></a>1.时间复杂度分析</h2><p>时间复杂度是一个<strong>函数</strong>，它定性描述了算法的运行时间。</p><p>O 用来表示上界，用它表示算法在最坏情况下运行时间的上界，就是对任意数据输入的运行时间的上界。</p><p>O 代表的就是一般情况，一般是数据是无序的。</p><h3 id="1-1如何描述时间时间复杂度"><a href="#1-1如何描述时间时间复杂度" class="headerlink" title="1.1如何描述时间时间复杂度"></a>1.1如何描述时间时间复杂度</h3><ul><li>考虑数据规模的差异</li><li>复杂表达式的简化</li><li>log以什么为底</li></ul><h3 id="1-2-递归算法的时间复杂度分析"><a href="#1-2-递归算法的时间复杂度分析" class="headerlink" title="1.2 递归算法的时间复杂度分析"></a>1.2 递归算法的时间复杂度分析</h3><p>递归算法的时间复杂度本质上要看<strong>递归的次数</strong>与<strong>递归中的操作次数</strong>的乘积</p><h2 id="2-空间复杂度分析"><a href="#2-空间复杂度分析" class="headerlink" title="2.空间复杂度分析"></a>2.空间复杂度分析</h2><p>空间复杂度考虑的是程序执行时占用内存空间的大小，而不是可执行文件的大小</p><p>在递归调用的时候，会出现空间复杂度为O（logn）的情况</p><h3 id="2-1-递归算法空间复杂度分析"><a href="#2-1-递归算法空间复杂度分析" class="headerlink" title="2.1 递归算法空间复杂度分析"></a>2.1 递归算法空间复杂度分析</h3><p>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归的深度</p><h4 id="2-1-1-斐波那契数"><a href="#2-1-1-斐波那契数" class="headerlink" title="2.1.1 斐波那契数"></a>2.1.1 斐波那契数</h4><p>非递归算法 时间复杂度（o(n)） 空间复杂度（o(1)）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci1</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) {</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (num&lt;<span class="number">3</span>){</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= num; i++) {</span><br><span class="line">          third = first + second;</span><br><span class="line">          first = second;</span><br><span class="line">          second = third;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> third;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>递归算法 时间复杂度（o(2^n)） 空间复杂度（o(n)）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span>{</span><br><span class="line"><span class="keyword">if</span>(i &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(i-<span class="number">1</span>)+fibonacci(i-<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化递归算法  时间复杂度（o(n)） 空间复杂度（o(n)）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second, <span class="type">int</span> n)</span>{</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">3</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>){</span><br><span class="line">        <span class="keyword">return</span> first+second;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> fibonacci(second,first+second,n-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-1-2-二分查找法"><a href="#2-1-2-二分查找法" class="headerlink" title="2.1.2 二分查找法"></a>2.1.2 二分查找法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>{</span><br><span class="line"><span class="keyword">if</span>(r&gt;=<span class="number">1</span>){</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]==x){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&gt;x){</span><br><span class="line">            <span class="keyword">return</span> binary_search(arr,l,mid-<span class="number">1</span>,x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度为 O（logn） 空间复杂度为 O(logn)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从0到1手写RPC</title>
      <link href="/2024/02/24/cong-0-dao-1-shou-xie-rpc/"/>
      <url>/2024/02/24/cong-0-dao-1-shou-xie-rpc/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="#什么是RPC"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E4%BB%80%E4%B9%88%E6%98%AFrpc">#</a><strong>什么是RPC</strong></h3><p>RPC（Remote Procedure Call）远程过程调用，简言之就是像调用本地方法一样调用远程服务。目前外界使用较多的有gRPC、Dubbo、Spring Cloud等。相信大家对RPC的概念都已经很熟悉了，这里不做过多介绍。</p><h3 id="为啥要自己写"><a href="#为啥要自己写" class="headerlink" title="#为啥要自己写"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E4%B8%BA%E5%95%A5%E8%A6%81%E8%87%AA%E5%B7%B1%E5%86%99">#</a>为啥要自己写</h3><p>为什么要自己写一个RPC框架，dubbo难道满足不了你？我觉得从个人成长上说，如果一个程序员能清楚的了解RPC框架所具备的要素，掌握RPC框架中涉及的服务注册发现、负载均衡、序列化协议、RPC通信协议、Socket通信、异步调用、熔断降级等技术，可以全方位的提升基本素质。虽然也有相关源码，但是只看源码容易眼高手低，动手写一个才是自己真正掌握这门技术的最优路径。（换个角度想想dubbo真的适合你们项目吗？有多少人觉得dubbo只是比feign性能好，更主流，大公司都用等等理由才用的？）</p><h2 id="RPC框架要素"><a href="#RPC框架要素" class="headerlink" title="#RPC框架要素"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#rpc%E6%A1%86%E6%9E%B6%E8%A6%81%E7%B4%A0">#</a><strong>RPC框架要素</strong></h2><p>一款分布式RPC框架离不开三个基本要素：</p><ul><li>服务提供方 Serivce Provider</li><li>服务消费方 Servce Consumer</li><li>注册中心 Registery</li></ul><p>围绕上面三个基本要素可以进一步扩展服务路由、负载均衡、服务熔断降级、序列化协议、通信协议等等。</p><ol><li><p><strong>注册中心</strong></p><p>主要是用来完成服务注册和发现的工作。虽然服务调用是服务消费方直接发向服务提供方的，但是现在服务都是集群部署，服务的提供者数量也是动态变化的，所以服务的地址也就无法预先确定。因此如何发现这些服务就需要一个统一注册中心来承载。</p></li><li><p><strong>服务提供方（RPC服务端）</strong></p><p>其需要对外提供服务接口，它需要在应用启动时连接注册中心，将服务名及其服务元数据发往注册中心。同时需要提供服务服务下线的机制。需要维护服务名和真正服务地址映射。服务端还需要启动Socket服务监听客户端请求。</p></li><li><p><strong>服务消费方（RPC客户端）</strong></p><p>客户端需要有从注册中心获取服务的基本能力，它需要在应用启动时，扫描依赖的RPC服务，并为其生成代理调用对象，同时从注册中心拉取服务元数据存入本地缓存，然后发起监听各服务的变动做到及时更新缓存。在发起服务调用时，通过代理调用对象，从本地缓存中获取服务地址列表，然后选择一种负载均衡策略筛选出一个目标地址发起调用。调用时会对请求数据进行序列化，并采用一种约定的通信协议进行socket通信。</p></li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="#技术选型"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B">#</a><strong>技术选型</strong></h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="#注册中心"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">#</a>注册中心</h3><p>目前成熟的注册中心有Zookeeper，Nacos，Consul，Eureka，它们的主要比较如下：</p><p><img src="https://returnac.cn/images/image_uZAdaXvPwp.png" alt="img"></p><p>我们这里采用nacos</p><h3 id="IO通信框架"><a href="#IO通信框架" class="headerlink" title="#IO通信框架"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#io%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6">#</a>IO通信框架</h3><p>本实现采用Netty作为底层通信框架，Netty是一个高性能事件驱动型的非阻塞的IO(NIO)框架。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="#通信协议"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">#</a>通信协议</h3><p>TCP通信过程中会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。所以需要对发送的数据包封装到一种通信协议里。</p><p>业界的主流协议的解决方案可以归纳如下：</p><ol><li>消息定长，例如每个报文的大小为固定长度100字节，如果不够用空格补足。</li><li>在包尾特殊结束符进行分割。</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。</li></ol><p>很明显1，2都有些局限性，本实现采用方案3，<strong>自定义协议</strong></p><h3 id="序列化协议"><a href="#序列化协议" class="headerlink" title="#序列化协议"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE">#</a>序列化协议</h3><p>常见的协议有JavaSerializer、json、Protobuf及Hessian。建议选用Protobuf，其序列化后码流小性能高，非常适合RPC调用，Google自家的gRPC也是用其作为通信协议。但是我们这里采用<strong>Hessian2</strong>序列化（懒，其他后续慢慢实现）</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="#整体架构"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">#</a>整体架构</h2><p><img src="https://returnac.cn/images/image_F6p-04GZCW.png" alt="img"></p><p>下面就来看看实现吧</p><h2 id="通信相关"><a href="#通信相关" class="headerlink" title="#通信相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3">#</a>通信相关</h2><h3 id="通信协议-1"><a href="#通信协议-1" class="headerlink" title="#通信协议"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-1">#</a><strong>通信协议</strong></h3><p><img src="https://returnac.cn/images/image_O-3Mh6cCHl.png" alt="img"></p><ul><li>第一个是魔法数，比如我定义为0x01F1。</li><li>第二个代表时间戳，以便对时间进行校验</li><li>第三个是消息类型，如0代表请求1代表响应。</li><li>第四个是加密序列号，采用随机的方式对消息体加密和解密</li><li>第五个表示消息长度，即此后面的内容是消息content。</li></ul><p>对应实体类如下：</p><p><img src="https://returnac.cn/images/image_0ptwGVjIDj.png" alt="img"></p><h3 id="编码器"><a href="#编码器" class="headerlink" title="#编码器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%BC%96%E7%A0%81%E5%99%A8">#</a><strong>编码器</strong></h3><p>也就是需要按顺序写入消息的字节到缓冲器，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;RpcRemoteMsg&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, RpcRemoteMsg rpcRemoteMsg, ByteBuf out)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 写入开头的标志</span></span><br><span class="line">        out.writeShort(rpcRemoteMsg.getStartSign());</span><br><span class="line">        <span class="comment">// 写入秒时间戳</span></span><br><span class="line">        out.writeInt(rpcRemoteMsg.getTimeStamp());</span><br><span class="line">        <span class="comment">// 写消息类型</span></span><br><span class="line">        out.writeShort(rpcRemoteMsg.getMsgType());</span><br><span class="line">        <span class="comment">// 写入加密序列号</span></span><br><span class="line">        out.writeShort(rpcRemoteMsg.getEncryptSequence());</span><br><span class="line">        <span class="comment">// 写入消息长度</span></span><br><span class="line">        out.writeInt(rpcRemoteMsg.getContentLength());</span><br><span class="line">        <span class="comment">// 写入消息主体</span></span><br><span class="line">        out.writeBytes(rpcRemoteMsg.getContent());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解码器"><a href="#解码器" class="headerlink" title="#解码器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%A7%A3%E7%A0%81%E5%99%A8">#</a><strong>解码器</strong></h3><p>这里省事，直接继承<strong>LengthFieldBasedFrameDecoder</strong>实现自己逻辑，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(EasyRpcDecoder.class);</span><br><span class="line">    <span class="comment">// 开始标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">short</span> <span class="variable">HEAD_START</span> <span class="operator">=</span> (<span class="type">short</span>) <span class="number">0x01F1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> {</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength, <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip)</span> {</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength, <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip, <span class="type">boolean</span> failFast)</span> {</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip, failFast);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcDecoder</span><span class="params">(ByteOrder byteOrder, <span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength, <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip, <span class="type">boolean</span> failFast)</span> {</span><br><span class="line">        <span class="built_in">super</span>(byteOrder, maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip, failFast);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 经过父解码器的处理 我们就不需要在考虑沾包和半包了</span></span><br><span class="line">        <span class="comment">// 当然，想要自己处理沾包和半包问题也不是不可以</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">decode</span> <span class="operator">=</span> (ByteBuf) <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (decode == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 开始标志校验  开始标志不匹配直接 过滤此条消息</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">startIndex</span> <span class="operator">=</span> decode.readShort();</span><br><span class="line">        <span class="keyword">if</span> (startIndex != HEAD_START) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 时间戳</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">timeStamp</span> <span class="operator">=</span> decode.readInt();</span><br><span class="line">        <span class="comment">// 请求还是响应  0：请求  1：响应</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">msgType</span> <span class="operator">=</span> decode.readShort();</span><br><span class="line">        <span class="comment">// 加密序列号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">encryptSequence</span> <span class="operator">=</span> decode.readShort();</span><br><span class="line">        <span class="comment">// 消息体长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">contentLength</span> <span class="operator">=</span> decode.readInt();</span><br><span class="line">        <span class="comment">// 读取消息</span></span><br><span class="line">        <span class="type">byte</span>[] msgByte = <span class="keyword">new</span> <span class="title class_">byte</span>[contentLength];</span><br><span class="line">        decode.readBytes(msgByte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息转成实体类 传递给下面的数据处理器</span></span><br><span class="line">        <span class="keyword">return</span> msgType == <span class="number">0</span> ? EncryptUtil.remoteMsgToRequest(encryptSequence,msgByte) : EncryptUtil.remoteMsgToResponse(encryptSequence,msgByte);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="nacos相关"><a href="#nacos相关" class="headerlink" title="#nacos相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#nacos%E7%9B%B8%E5%85%B3">#</a>nacos相关</h2><p>nacos其实很简单一共四个方法：</p><ul><li><strong>registerInstance</strong> ：注册</li><li><strong>deregisterInstance</strong> ： 下线</li><li><strong>getAllInstances</strong> ： 获取所有实例</li><li><strong>subscribe</strong> ：订阅服务</li></ul><p>我们nacos全局就一个使用类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosEasyRpcCenter</span> <span class="keyword">implements</span> <span class="title class_">EasyRpcCenter</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(NacosEasyRpcCenter.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DEFAULT_NAMESPACE</span> <span class="operator">=</span> <span class="string">"public"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DEFAULT_META_PARAM</span> <span class="operator">=</span> <span class="string">"easyRpcMeta"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NacosNamingService nacosNamingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcApplicationConfig applicationConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcCenterConfig centerConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NacosEasyRpcCenter</span><span class="params">(EasyRpcCenterConfig centerConfig, EasyRpcApplicationConfig rpcApplicationConfig)</span> {</span><br><span class="line">        Assert.isTrue(StrUtil.isNotEmpty(centerConfig.getAddress()), <span class="string">"registry address cannot be empty"</span>);</span><br><span class="line">        Assert.isTrue(StrUtil.isNotEmpty(centerConfig.getGroup()), <span class="string">"registry group cannot be empty"</span>);</span><br><span class="line">        <span class="built_in">this</span>.applicationConfig = rpcApplicationConfig;</span><br><span class="line">        <span class="built_in">this</span>.centerConfig = centerConfig;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">"serverAddr"</span>, String.format(<span class="string">"%s:%d"</span>, centerConfig.getAddress(), centerConfig.getPort()));</span><br><span class="line">        properties.setProperty(<span class="string">"namespace"</span>, StrUtil.emptyToDefault(centerConfig.getNamespace(), DEFAULT_NAMESPACE));</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="built_in">this</span>.nacosNamingService = <span class="keyword">new</span> <span class="title class_">NacosNamingService</span>(properties);</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center init error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EasyRpcRunException</span>(e.getErrMsg());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(ServiceInstance serviceInstance)</span> {</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">        instance.setIp(serviceInstance.getIp());</span><br><span class="line">        instance.setPort(serviceInstance.getPort());</span><br><span class="line">        Map&lt;String, String&gt; meteData=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        meteData.put(DEFAULT_META_PARAM,JSONObject.toJSONString(serviceInstance.getMetaDataSet()));</span><br><span class="line">        instance.setMetadata(meteData);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            nacosNamingService.registerInstance(applicationConfig.getName(), centerConfig.getGroup(),instance);</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center register error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EasyRpcRunException</span>(e.getErrMsg());</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Easy-Rpc -&gt; nacos center register:[ serviceName:{} group:{} ] success"</span>,applicationConfig.getName(),centerConfig.getGroup());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deregisterInstance</span><span class="params">(ServiceInstance serviceInstance)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            nacosNamingService.deregisterInstance(applicationConfig.getName(), centerConfig.getGroup(),serviceInstance.getIp(),serviceInstance.getPort());</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center deregister error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Easy-Rpc -&gt; nacos center deregister:[ serviceName:{} group:{} ] success"</span>,applicationConfig.getName(),centerConfig.getGroup());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title function_">getAllInstances</span><span class="params">(String serviceId)</span> {</span><br><span class="line">        List&lt;ServiceInstance&gt; serviceInstanceList = EasyRpcInstanceCache.getServiceInstanceList(serviceId);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isEmpty(serviceInstanceList)){</span><br><span class="line">            serviceInstanceList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                List&lt;Instance&gt; allInstances = nacosNamingService.getAllInstances(serviceId, centerConfig.getGroup());</span><br><span class="line">                <span class="keyword">if</span>(CollectionUtil.isNotEmpty(allInstances)){</span><br><span class="line">                    <span class="keyword">for</span>(Instance instance:allInstances){</span><br><span class="line">                        serviceInstanceList.add(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(instance.getIp(), instance.getPort()));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">                log.error(<span class="string">"Easy-Rpc -&gt; nacos center deregister error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">            }</span><br><span class="line">            EasyRpcInstanceCache.updateServiceInstanceInfo(serviceId,serviceInstanceList);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> serviceInstanceList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeInstance</span><span class="params">(String serviceId)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            nacosNamingService.subscribe(serviceId, centerConfig.getGroup(), <span class="keyword">new</span> <span class="title class_">AbstractEventListener</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> {</span><br><span class="line">                    <span class="keyword">return</span> ThreadPoolUtils.subscribeInstancePool;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> {</span><br><span class="line">                    <span class="type">NamingEvent</span> <span class="variable">namingEvent</span> <span class="operator">=</span> (NamingEvent) event;</span><br><span class="line">                    List&lt;Instance&gt; allInstances = namingEvent.getInstances();</span><br><span class="line">                    List&lt;ServiceInstance&gt; serviceInstanceList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">                    <span class="keyword">if</span>(CollectionUtil.isNotEmpty(allInstances)){</span><br><span class="line">                        <span class="keyword">for</span>(Instance instance:allInstances){</span><br><span class="line">                            serviceInstanceList.add(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(instance.getIp(), instance.getPort()));</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 直接把本地的全量替换</span></span><br><span class="line">                    EasyRpcInstanceCache.updateServiceInstanceInfo(serviceId,serviceInstanceList);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (NacosException e) {</span><br><span class="line">            log.error(<span class="string">"Easy-Rpc -&gt; nacos center subscribe error:{}"</span>, e.getErrMsg(), e);</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"Easy-Rpc -&gt; nacos center subscribe:[{}] success"</span>,serviceId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="消费者相关"><a href="#消费者相关" class="headerlink" title="#消费者相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%B8%E5%85%B3">#</a>消费者相关</h2><p>消费者不用想，凡是这种RPC的几乎都是动态代理，问题是用什么样的方法为它生成代理，我们以Feign为例看看它是怎么做的？</p><p><strong>启动注解→扫描包下被注解标识的接口→获取封装信息→生成FeignClientFactoryBean注入容器</strong></p><p><img src="https://returnac.cn/images/image_CslT48jUM2.png" alt="img"></p><p>感兴趣的可以自己去看看，最终我们采用注解调用时，获取的无非是<strong>factoryBean.getObject();</strong> 返回的动态代理对象罢了</p><p>想想这样合适吗？<strong>他需要扫描整个包然后生成代理对象再放入容器，要是这个对象压根没人用岂不是白生成了？</strong> 所以我这里改了一下，不再扫描包生成了，<strong>我在你属性注入时才生成！</strong></p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="#自定义注解"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">#</a>自定义注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target({ElementType.FIELD})</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EasyRpcServiceInvoke {</span><br><span class="line">    <span class="comment">// 服务项ID</span></span><br><span class="line">    String <span class="title function_">serviceId</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 服务发布的Bean 名称</span></span><br><span class="line">    String <span class="title function_">beanRefName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此注解代表我需要获取远程调用的代理对象，如：</p><p><img src="https://returnac.cn/images/image_yXBIfqLXL9.png" alt="img"></p><h3 id="消费者后置处理器"><a href="#消费者后置处理器" class="headerlink" title="#消费者后置处理器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8">#</a>消费者后置处理器</h3><p>所以我要在Bean属性注入的时候，为它注入一个动态代理对象，同时添加需要订阅的服务项</p><p>这个服务项在Nacos中就是服务名，就好比feign也需要指定一个服务名是吧</p><p><img src="https://returnac.cn/images/image_a_G9shqtad.png" alt="img"></p><p>为什么dubbo不需要？因为dubbo在nacos不是以服务为单位，而是以暴露的接口服务为单位，如下：</p><p><img src="https://returnac.cn/images/image_L3v3aEw_yv.png" alt="img"></p><h3 id="代理对象生成"><a href="#代理对象生成" class="headerlink" title="#代理对象生成"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90">#</a>代理对象生成</h3><p>这里采用了Cglib动态代理，为什么不用jdk动态代理，主要是为了避免反射耗时，也方便以后拓展的灵活性</p><p><strong>代理工厂：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibInvokeBeanProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> colins</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  获取客户端远程调用代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getClientInvokeProxy</span><span class="params">(Class&lt;T&gt; interfaceClass, String serviceId, String beanRef,String interfaces)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(interfaceClass, <span class="keyword">new</span> <span class="title class_">CglibInvocationHandler</span>(serviceId, beanRef,interfaces));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代理处理类：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanRef;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibInvocationHandler</span><span class="params">(String serviceId, String beanRef, String interfaces)</span> {</span><br><span class="line">        <span class="built_in">this</span>.serviceId = serviceId;</span><br><span class="line">        <span class="built_in">this</span>.beanRef = beanRef;</span><br><span class="line">        <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        List&lt;ServiceInstance&gt; serviceInstanceList = EasyRpcInstanceCache.getServiceInstanceList(serviceId);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(serviceInstanceList)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EasyRpcException</span>(String.format(<span class="string">"[ %d ] No corresponding service found "</span>, serviceId));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建请求参数</span></span><br><span class="line">        <span class="type">EasyRpcRequest</span> <span class="variable">easyRpcRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyRpcRequest</span>(UUID.randomUUID().toString(),beanRef, interfaces, method.getName(), method.getParameterTypes(), objects);</span><br><span class="line">        <span class="comment">// 获取会话</span></span><br><span class="line">        <span class="type">EasyRpcSession</span> <span class="variable">easyRpcSession</span> <span class="operator">=</span> EasyRpcSessionFactory.getInstance().openSession(serviceId, easyRpcRequest, serviceInstanceList);</span><br><span class="line">        <span class="comment">// 会话执行调用</span></span><br><span class="line">        <span class="keyword">return</span> easyRpcSession.exec();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="生产者相关"><a href="#生产者相关" class="headerlink" title="#生产者相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%94%9F%E4%BA%A7%E8%80%85%E7%9B%B8%E5%85%B3">#</a>生产者相关</h2><h3 id="自定义注解-1"><a href="#自定义注解-1" class="headerlink" title="#自定义注解"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-1">#</a>自定义注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target({ElementType.TYPE})</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EasyRpcServicePublish {</span><br><span class="line">    <span class="comment">// 暴露出去的bean名称 默认就是bean默认名称</span></span><br><span class="line">    String <span class="title function_">beanRefName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="生产者后置处理器"><a href="#生产者后置处理器" class="headerlink" title="#生产者后置处理器"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%94%9F%E4%BA%A7%E8%80%85%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8">#</a>生产者后置处理器</h3><p>主要两件事：</p><ul><li>收集暴露出去的bean集合</li><li>收集需要暴露出去的元数据</li></ul><p><img src="https://returnac.cn/images/image_s3siw1oxfY.png" alt="img"></p><p><strong>为什么要收集暴露出去的服务bean？</strong></p><p>仔细看一下上面的注解是一个复合注解，我暴露出去提供远程调用服务的对象在容器中不就是一个bean吗？<strong>所以如果有消费者调用暴露的服务，本质不就是调用远程容器中的bean对象吗？</strong> 所以我给它收集缓存起来，要是有别的服务远程调用过来，我直接走缓存反射执行方法就好了</p><h2 id="容器相关"><a href="#容器相关" class="headerlink" title="#容器相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3">#</a>容器相关</h2><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="#容器启动"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8">#</a>容器启动</h3><p>需要做三件事，启动netty server 、发布服务、订阅服务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcStartEvent</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcConfig rpcConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcCenter rpcCenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcStartEvent</span><span class="params">(EasyRpcConfig rpcConfig, EasyRpcCenter rpcCenter)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rpcConfig = rpcConfig;</span><br><span class="line">        <span class="built_in">this</span>.rpcCenter = rpcCenter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> {</span><br><span class="line">        <span class="comment">// 启动NettyServer</span></span><br><span class="line">        ThreadPoolUtils.startNettyPool.execute(<span class="keyword">new</span> <span class="title class_">EasyRpcServer</span>(rpcConfig.getProtocol().getPort(), <span class="keyword">new</span> <span class="title class_">EasyRpcServerHandlerInit</span>()));</span><br><span class="line">        <span class="comment">// 发布服务</span></span><br><span class="line">        rpcCenter.registerInstance(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(rpcConfig.getProtocol().getPort(), EasyRpcSpringConstant.serviceMetaDataList));</span><br><span class="line">        <span class="comment">// 订阅服务</span></span><br><span class="line">        EasyRpcSpringConstant.serviceIdList.forEach(item-&gt;{</span><br><span class="line">            rpcCenter.subscribeInstance(item);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="容器关闭"><a href="#容器关闭" class="headerlink" title="#容器关闭"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%AE%B9%E5%99%A8%E5%85%B3%E9%97%AD">#</a>容器关闭</h3><p>只需要让该服务注册下线即可，如果想优雅一点，可以把Netty相关也全关闭（这里先不处理）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyRpcCloseEvent</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextClosedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcConfig rpcConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EasyRpcCenter rpcCenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyRpcCloseEvent</span><span class="params">(EasyRpcConfig rpcConfig, EasyRpcCenter rpcCenter)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rpcConfig = rpcConfig;</span><br><span class="line">        <span class="built_in">this</span>.rpcCenter = rpcCenter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> {</span><br><span class="line">        <span class="comment">// 注销服务即可 其他中断无所谓</span></span><br><span class="line">        <span class="comment">// netty server下线 client会断开重连</span></span><br><span class="line">        rpcCenter.deregisterInstance(<span class="keyword">new</span> <span class="title class_">ServiceInstance</span>(rpcConfig.getProtocol().getPort()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调用相关"><a href="#调用相关" class="headerlink" title="#调用相关"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3">#</a>调用相关</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="#消费者"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B6%88%E8%B4%B9%E8%80%85">#</a>消费者</h3><p>消费者在调用的时候本质是执行代理对象中的逻辑，也就是往netty管道中写入数据，不在多说，看看发送数据的实体类</p><p><img src="https://returnac.cn/images/image_UtLgkSMMy5.png" alt="img"></p><h3 id="生产者"><a href="#生产者" class="headerlink" title="#生产者"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E7%94%9F%E4%BA%A7%E8%80%85">#</a>生产者</h3><p>生产者就是根据传来的信息，拿到缓存中对象的bean对象反射执行方法，然后返回</p><p><img src="https://returnac.cn/images/image_j9vfUh55Go.png" alt="img"></p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="#测试结果"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C">#</a>测试结果</h2><p>消费端16线程，所以均为一台机器(生产、消费、jmeter都在一台机器)</p><p><strong>测试结果仅供参考，在好的条件下，某些配置设置合适点，吞吐量应该更高</strong></p><table><thead><tr><th></th><th>无传参 无返回</th><th>POJO传参 简单返回</th><th>简单传参 POJO返回</th><th>无传参 POJO_list返回</th></tr></thead><tbody><tr><td>100并发 1000次请求 （共计10000）</td><td>1W左右QPS</td><td>9350左右QPS</td><td>8900左右QPS</td><td>7500左右QPS</td></tr><tr><td>300并发 1000次请求 （共计30000）</td><td>9200左右QPS</td><td>8700左右QPS</td><td>8000左右QPS</td><td>6800左右QPS</td></tr><tr><td>500并发 1000次请求 （共计50000）</td><td>8500左右QPS</td><td>7800左右QPS</td><td>7800左右QPS</td><td>6800左右QPS</td></tr></tbody></table><h2 id="后续拓展"><a href="#后续拓展" class="headerlink" title="#后续拓展"></a><a href="https://returnac.cn/pages/frame/netty/%E4%BB%8E0-1%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6.html#%E5%90%8E%E7%BB%AD%E6%8B%93%E5%B1%95">#</a>后续拓展</h2><p>从以上可以看到很多东西都还没实现，只能说基本雏形搭完了，后续什么SPI机制、服务治理相关、多协议拓展、配置丰富化、多注册中心等等都是可以做的事，最后再看一下架构吧</p><p><img src="https://returnac.cn/images/image_F6p-04GZCW.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
